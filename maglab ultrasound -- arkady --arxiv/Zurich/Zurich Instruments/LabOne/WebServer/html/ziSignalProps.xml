<?xml version="1.0" encoding="UTF-8" ?>
<signalProps xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="ziSignalProps.xsd">

<!--
       Expressions:

       Any ${...} within property value is treated as an expression. Expression evaluated using parameter
       values that correspond to the actual path, result substituted in place of ${...}. Evaluation result
       is lexically casted to string.

       Within expressions the following parameters can be used:
         - p0:            expands to the entire source path
         - p1...pN:       expands to the corresponding regexp matching group (first group has index 1)
         - sourceUnit:    expands to the result of the unit calculator. Only allowed in <unit> value and
                          only in ${sourceUnit} form, without any operations!

       In case math operation is applied to a parameter, its value is casted to an integer. If can not be
       casted, or there is any other expression evaluation error, detailed error message will be logged,
       and the string "[ERROR]" will be returned as an expression evaluation result.


       TODO:
         - Reference to the parent node properties as parameters within expression
         - References to reusable signal groups
         - Cascaded rules that inherit properties and allow to override selected properties on demand
         - Support of generic functions of singnals with help of cascaded rules, such as PWR, BWN, etc.
         - limits per <group>: signals sharing same group must have same limit settings

       Note for units:
         Units for calibrated signals look like "V/V", "V^2/V^2", etc. Strictly speaking, it should be
         "${sourceUnit}/${sourceUnit}", etc., but since DynamicUnit calculates these to "no unit" anyways,
         hard coded "V/V" is kept (along with "RAW" unit calc selector). This is considered fine for the
         moment, however at some point may need implementation. Here two blockers seen:
           - Prevent DynamicUnit from calculating away "<same unit>/<same unit>" constructs to "no unit"
           - Support grouping by parentheses in the DynamicUnit parser: ${sourceUnit} may be already
             complex unit like "V*A", and substitution in "1/${sourceUnit}" will not produce correct
             result without additional grouping. Compare: "1/V*A" -> "A/V" and "1/(V*A)" -> "1/V/A".

       Note 2 for units:
         As an interim solution, introduced "LITERAL" unit calculator, which skips the dynamic unit parsing,
         hence allows units like "V/V". For any subsequent unit calculation literal is treated as a unique unit.
-->

  <!-- ******************** Default, returned in case the path is not matching any of the regexps -->
  <defaultNodeRule match=".*"> <!-- TODO(2K): 'match' for default node is a workaround, should be handled internally -->
    <display>${p0}</display>
  </defaultNodeRule>

<!-- TODO(2K): don't remove - work in progress
  <suffixRule suffix="Rms">
    <display>Std Deviation ${source}</display>
    <variable>${source}stddev</variable>
    <limit>
      <label>Std Deviation</label>
      <symbol>${source}rms</symbol>
      <unit>${source}</unit>
    </limit>
  </suffixRule>

  <suffixRule suffix="Pwr">
    <power>true</power>
    <display>Power ${source}</display>
    <variable>${source}pwr</variable>
    <limit>
      <label>Power</label>
      <symbol>${source}&#178;avg</symbol>
      <unit>${source}</unit> <!- - unit will be squared by DynamicUnit due to 'power' - ->
    </limit>
  </suffixRule>

  <suffixRule suffix="BWN">
    <bw>true</bw>
    <display>${source} 1Hz BW</display>
    <variable>${source}</variable>
    <limit>
      <label>1Hz BW</label>
      <symbol>${source}avg/sqrt(Hz)</symbol>
      <unit>${source}/Hz^0.5</unit>
    </limit>
  </suffixRule>

  <suffixRule suffix="RmsBWN">
    <bw>true</bw>
    <display>${source} Noise 1Hz BW</display>
    <variable>${source}stddev</variable>
    <limit>
      <label>Noise 1Hz BW</label>
      <symbol>${source}rms/sqrt(Hz)</symbol>
      <unit>${source}/Hz^0.5</unit>
    </limit>
  </suffixRule>

  <suffixRule suffix="PwrBWN">
    <bw>true</bw>
    <power>true</power>
    <display>Power ${source} 1Hz BW</display>
    <variable>${source}pwr</variable>
    <limit>
      <label>Power 1Hz BW</label>
      <symbol>${source}&#178;avg/Hz</symbol>
      <unit>${source}/Hz^0.5</unit> <!- - unit will be squared by DynamicUnit due to 'power' - ->
    </limit>
  </suffixRule>

  <suffixRule suffix="Cal">
    <display>Norm ${source}</display>
    <variable>${source}</variable>
    <limit>
      <label>Norm Amplitude</label>
      <symbol>${source}avg/${source}ref</symbol>
      <unit>${source}/${source}</unit>
    </limit>
  </suffixRule>

  <suffixRule suffix="RmsCal">
    <display>Norm Std Dev ${source}</display>
    <variable>${source}stddev</variable>
    <limit>
      <label>Norm Std Dev</label>
      <symbol>${source}rms/${source}rmsref</symbol>
      <unit>${source}/${source}</unit>
    </limit>
  </suffixRule>

  <suffixRule suffix="PwrCal">
    <power>true</power>
    <display>Norm Power ${source}</display>
    <variable>${source}pwr</variable>
    <limit>
      <label>Norm Power</label>
      <symbol>${source}&#178;avg/${source}&#178;ref</symbol>
      <unit>${source}/${source}</unit> <!- - unit will be squared by DynamicUnit due to 'power' - ->
    </limit>
  </suffixRule>

  <suffixRule suffix="BWNCal">
    <bw>true</bw>
    <display>${source}</display>
    <variable>${source}</variable>
    <limit>
      <label>${source}</label>
      <symbol>${source}</symbol>
      <unit>${source}</unit>
    </limit>
  </suffixRule>

  <suffixRule suffix="RmsBWNCal">
    <bw>true</bw>
    <display>${source}</display>
    <variable>${source}</variable>
    <limit>
      <label>${source}</label>
      <symbol>${source}</symbol>
      <unit>${source}</unit>
    </limit>
  </suffixRule>

  <suffixRule suffix="PwrBWNCal">
    <bw>true</bw>
    <power>true</power>
    <display>${source}</display>
    <variable>${source}</variable>
    <limit>
      <label>${source}</label>
      <symbol>${source}</symbol>
      <unit>${source}</unit> <!- - unit will be squared by DynamicUnit due to 'power' - ->
    </limit>
  </suffixRule>
-->

  <branchRule match="/dev([0-9]+)">
    <display>Device ${p1}</display>
    <signalGroup>
      <signalRule name="oscphiuhf3" index="0">
        <display>Osc &#966; Demod 4</display>
        <!-- 10: Osc phi Demod 4 / UHF -->
        <scopeIndex>10</scopeIndex>
        <unitCalcSelector>BASE</unitCalcSelector>
        <featureIndex>10</featureIndex>
      </signalRule>
      <signalRule name="oscphiuhf7" index="1">
        <display>Osc &#966; Demod 8</display>
        <!-- 11: Osc phi Demod 8 / UHF -->
        <scopeIndex>11</scopeIndex>
        <unitCalcSelector>BASE</unitCalcSelector>
        <featureIndex>11</featureIndex>
      </signalRule>
      <signalRule name="oscphimfli1" index="2">
        <display>Osc &#966; Demod 2</display>
        <!-- 10: Osc phi Demod 2 / MF -->
        <scopeIndex>10</scopeIndex>
        <unitCalcSelector>BASE</unitCalcSelector>
        <featureIndex>10</featureIndex>
      </signalRule>
      <signalRule name="oscphimflimd1" index="2">
        <display>Osc &#966; Demod 2</display>
        <!-- 10: Osc phi Demod 2 / MF -->
        <scopeIndex>10</scopeIndex>
        <unitCalcSelector>BASE</unitCalcSelector>
        <featureIndex>10</featureIndex>
      </signalRule>
      <signalRule name="oscphimflimd3" index="3">
        <display>Osc &#966; Demod 4</display>
        <!-- 11: Osc phi Demod 4 / MF -->
        <scopeIndex>11</scopeIndex>
        <unitCalcSelector>BASE</unitCalcSelector>
        <featureIndex>11</featureIndex>
      </signalRule>
    </signalGroup>
  </branchRule>

<!-- aucarts -->

  <branchRule match="/dev[0-9]+/aucarts">
    <display>Arithmetic Units Cartesian</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/aucarts/([0-9]+)">
    <display>AU Cartesian ${p1+1}</display>
    <scopeIndex>${p1+112}</scopeIndex>
    <unitCalcSelector>AUCART</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
  </branchRule>

  <leafRule match="/dev[0-9]+/aucarts/([0-9]+)/sample">
    <dataType>sample</dataType>
    <display>AU Cartesian ${p1+1}</display>
    <treeDisplay>Sample</treeDisplay>
    <variable>value</variable>
    <group>Arithmetic</group>
    <limit>
      <label>Amplitude</label>
      <symbol>U</symbol>
      <unit>${sourceUnit}</unit>
      <pmin>-2.0</pmin>
      <pmax>2.0</pmax>
      <mapping>LINEAR</mapping>
    </limit>
    <unitCalcSelector>AUCART</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
    <signalGroup>
      <signalRule name="Rms" index="0" module="sweeper">
        <display>Std Deviation</display>
        <variable>value</variable>
        <group>AU Cart</group>
        <limit>
          <label>Std Dev AU Cartesian</label>
          <symbol>Urms</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Pwr" index="0" module="sweeper">
        <power>true</power>
        <display>Power</display>
        <variable>value</variable>
        <group>AU Cart</group>
        <limit>
          <label>Pwr AU Cartesian</label>
          <symbol>U&#178;avg</symbol>
          <unit>${sourceUnit}</unit> <!-- will be squared due to 'power' -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="BWN" index="0" module="sweeper">
        <display>Amplitude</display>
        <variable>value</variable>
        <group>AU Cart</group>
        <limit>
          <label>AU Cartesian</label>
          <symbol>Amplitude</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="RmsBWN" index="0" module="sweeper">
        <display>Std Deviation</display>
        <variable>value</variable>
        <group>AU Cart</group>
        <limit>
          <label>Std Dev AU Cartesian</label>
          <symbol>Urms</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="PwrBWN" index="0" module="sweeper">
        <power>true</power>
        <display>Power</display>
        <variable>value</variable>
        <group>AU Cart</group>
        <limit>
          <label>Pwr AU Cartesian</label>
          <symbol>U&#178;avg</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit> <!-- will be squared due to 'power' -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Cal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Amplitude</display>
        <variable>value</variable>
        <group>AU Cart</group>
        <limit>
          <label>Norm AU Cartesian</label>
          <symbol>Uavg/Uref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="RmsCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Deviation</display>
        <variable>value</variable>
        <group>AU Cart</group>
        <limit>
          <label>Norm Std Dev AU Cartesian</label>
          <symbol>Urms/Urmsref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="PwrCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Power</display>
        <variable>value</variable>
        <group>AU Cart</group>
        <limit>
          <label>Norm Pwr AU Cartesian</label>
          <symbol>U&#178;avg/U&#178;ref</symbol>
          <unit>V/V</unit> <!-- will be squared due to 'power' --> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="BWNCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Amplitude</display>
        <variable>value</variable>
        <group>AU Cart</group>
        <limit>
          <label>Norm AU Cartesian</label>
          <symbol>Uavg/Uref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="RmsBWNCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Deviation</display>
        <variable>value</variable>
        <group>AU Cart</group>
        <limit>
          <label>Norm Std Dev AU Cartesian</label>
          <symbol>Urms/Urmsref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="PwrBWNCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Power</display>
        <variable>value</variable>
        <group>AU Cart</group>
        <limit>
          <label>Norm Pwr AU Cartesian</label>
          <symbol>U&#178;avg/U&#178;ref</symbol>
          <unit>V/V</unit> <!-- will be squared due to 'power' --> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
    </signalGroup>
  </leafRule>

  <leafRule match="/dev[0-9]+/aucarts/([0-9]+)/rate">
    <dataType>double</dataType>
    <display>Sampling Rate</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/aucarts/([0-9]+)/value">
    <dataType>double</dataType>
    <display>Sample Value</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/aucarts/([0-9]+)/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/aucarts/([0-9]+)/mode">
    <dataType>int</dataType>
    <display>Mode</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/aucarts/([0-9]+)/ops">
    <display>Operations</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/aucarts/([0-9]+)/ops/([0-9]+)">
    <display>Op ${p2+1}</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/aucarts/([0-9]+)/ops/([0-9]+)/coeff">
    <dataType>int</dataType>
    <display>Coefficient</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/aucarts/([0-9]+)/ops/([0-9]+)/demodselect">
    <dataType>int</dataType>
    <display>Channel Selection</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/aucarts/([0-9]+)/ops/([0-9]+)/scale">
    <dataType>double</dataType>
    <display>Scale Factor</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/aucarts/([0-9]+)/ops/([0-9]+)/value">
    <dataType>int</dataType>
    <display>Signal Selection</display>
  </leafRule>

<!-- aupolars -->

  <branchRule match="/dev[0-9]+/aupolars">
    <display>Arithmetic Units Polar</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/aupolars/([0-9]+)">
    <display>AU Polar ${p1+1}</display>
    <scopeIndex>${p1+128}</scopeIndex>
    <unitCalcSelector>AUPOLAR</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
  </branchRule>

  <leafRule match="/dev[0-9]+/aupolars/([0-9]+)/sample">
    <dataType>sample</dataType>
    <display>AU Polar ${p1+1}</display>
    <treeDisplay>Sample</treeDisplay>
    <variable>value</variable>
    <group>Arithmetic</group>
    <limit>
      <label>Amplitude</label>
      <symbol>U</symbol>
      <unit>${sourceUnit}</unit>
      <pmin>-2.0</pmin>
      <pmax>2.0</pmax>
      <mapping>LINEAR</mapping>
    </limit>
    <unitCalcSelector>AUPOLAR</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
    <signalGroup>
      <signalRule name="Rms" index="0" module="sweeper">
        <display>Std Deviation</display>
        <variable>value</variable>
        <group>AU Polar</group>
        <limit>
          <label>Std Dev AU Polar</label>
          <symbol>Urms</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Pwr" index="0" module="sweeper">
        <power>true</power>
        <display>Power</display>
        <variable>value</variable>
        <group>AU Polar</group>
        <limit>
          <label>Pwr AU Polar</label>
          <symbol>U&#178;avg</symbol>
          <unit>${sourceUnit}</unit> <!-- will be squared due to 'power' -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="BWN" index="0" module="sweeper">
        <display>Amplitude</display>
        <variable>value</variable>
        <group>AU Polar</group>
        <limit>
          <label>AU Polar</label>
          <symbol>Amplitude</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="RmsBWN" index="0" module="sweeper">
        <display>Std Deviation</display>
        <variable>value</variable>
        <group>AU Polar</group>
        <limit>
          <label>Std Dev AU Polar</label>
          <symbol>Urms</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="PwrBWN" index="0" module="sweeper">
        <power>true</power>
        <display>Power</display>
        <variable>value</variable>
        <group>AU Polar</group>
        <limit>
          <label>Pwr AU Polar</label>
          <symbol>U&#178;avg</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit> <!-- will be squared due to 'power' -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Cal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Amplitude</display>
        <variable>value</variable>
        <group>AU Polar</group>
        <limit>
          <label>Norm AU Polar</label>
          <symbol>Uavg/Uref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="RmsCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Deviation</display>
        <variable>value</variable>
        <group>AU Polar</group>
        <limit>
          <label>Norm Std Dev AU Polar</label>
          <symbol>Urms/Urmsref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="PwrCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Power</display>
        <variable>value</variable>
        <group>AU Polar</group>
        <limit>
          <label>Norm Pwr AU Polar</label>
          <symbol>U&#178;avg/U&#178;ref</symbol>
          <unit>V/V</unit> <!-- will be squared due to 'power' --> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="BWNCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Amplitude</display>
        <variable>value</variable>
        <group>AU Polar</group>
        <limit>
          <label>Norm AU Polar</label>
          <symbol>Uavg/Uref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="RmsBWNCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Deviation</display>
        <variable>value</variable>
        <group>AU Polar</group>
        <limit>
          <label>Norm Std Dev AU Polar</label>
          <symbol>Urms/Urmsref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="PwrBWNCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Power</display>
        <variable>value</variable>
        <group>AU Polar</group>
        <limit>
          <label>Norm Pwr AU Polar</label>
          <symbol>U&#178;avg/U&#178;ref</symbol>
          <unit>V/V</unit> <!-- will be squared due to 'power' --> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
    </signalGroup>
  </leafRule>

  <leafRule match="/dev[0-9]+/aupolars/([0-9]+)/rate">
    <dataType>double</dataType>
    <display>Sampling Rate</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/aupolars/([0-9]+)/value">
    <dataType>double</dataType>
    <display>Sample Value</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/aupolars/([0-9]+)/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/aupolars/([0-9]+)/mode">
    <dataType>int</dataType>
    <display>Mode</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/aupolars/([0-9]+)/ops">
    <display>Operations</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/aupolars/([0-9]+)/ops/([0-9]+)">
    <display>Op ${p2+1}</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/aupolars/([0-9]+)/ops/([0-9]+)/coeff">
    <dataType>int</dataType>
    <display>Coefficient</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/aupolars/([0-9]+)/ops/([0-9]+)/demodselect">
    <dataType>int</dataType>
    <display>Channel Selection</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/aupolars/([0-9]+)/ops/([0-9]+)/scale">
    <dataType>double</dataType>
    <display>Scale Factor</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/aupolars/([0-9]+)/ops/([0-9]+)/value">
    <dataType>int</dataType>
    <display>Signal Selection</display>
  </leafRule>

<!-- auxouts -->

  <branchRule match="/dev[0-9]+/auxouts">
    <display>Auxiliary Outputs</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/auxouts/([0-9]+)">
    <display>Auxiliary Output ${p1+1}</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/auxouts/([0-9]+)/offset">
    <dataType>double</dataType>
    <display>Aux Out ${p1+1} Offset</display>
    <treeDisplay>Offset</treeDisplay>
    <limit>
      <label>Offset</label>
      <symbol>v</symbol>
      <unit>V</unit> <!-- TODO(2K): Is auxout offset fixed "V" or is it same as value? -->
      <pmin>0</pmin>
      <pmax>1</pmax>
      <mapping>LINEAR</mapping>
    </limit>
    <unitCalcSelector>RAW</unitCalcSelector>
  </leafRule>

  <leafRule match="/dev[0-9]+/auxouts/([0-9]+)/value">
    <dataType>double</dataType>
    <display>Aux Output ${p1+1}</display>
    <treeDisplay>Value</treeDisplay>
    <group>Auxout</group>
    <limit>
      <label>Auxout</label>
      <symbol>U</symbol>
      <unit>V</unit>
      <pmin>-2.0</pmin>
      <pmax>2.0</pmax>
      <mapping>LINEAR</mapping>
    </limit>
    <unitCalcSelector>RAW</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
    <signal>Amplitude</signal>
  </leafRule>

  <leafRule match="/dev[0-9]+/auxouts/([0-9]+)/demodselect">
    <dataType>int</dataType>
    <display>Channel Selection</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/auxouts/([0-9]+)/limitlower">
    <dataType>double</dataType>
    <display>Lower Limit</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/auxouts/([0-9]+)/limitupper">
    <dataType>double</dataType>
    <display>Upper Limit</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/auxouts/([0-9]+)/outputselect">
    <dataType>int</dataType>
    <display>Signal Selection</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/auxouts/([0-9]+)/preoffset">
    <dataType>double</dataType>
    <display>Pre-Offset</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/auxouts/([0-9]+)/scale">
    <dataType>double</dataType>
    <display>Scale Factor</display>
    <unitCalcSelector>AUXOUTSCALE</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
  </leafRule>

<!-- boxcars -->

  <branchRule match="/dev[0-9]+/boxcars">
    <display>Boxcars</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/boxcars/([0-9]+)">
    <display>Boxcar ${p1+1}</display>
    <scopeIndex>${p1+96}</scopeIndex>
    <unitCalcSelector>BOXCAR</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
  </branchRule>

  <leafRule match="/dev[0-9]+/boxcars/([0-9]+)/sample">
    <dataType>sample</dataType>
    <display>Boxcar ${p1+1}</display>
    <treeDisplay>Sample</treeDisplay>
    <variable>value</variable>
    <group>Boxcar</group>
    <limit>
      <label>Boxcar</label>
      <symbol>U</symbol>
      <unit>${sourceUnit}</unit>
      <pmin>-2.0</pmin>
      <pmax>2.0</pmax>
      <mapping>LINEAR</mapping>
    </limit>
    <unitCalcSelector>BOXCAR</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
    <signal>Amplitude</signal>
    <signalGroup>
      <signalRule name="Rms" index="0" module="sweeper">
        <display>Std Deviation</display>
        <variable>stddev</variable>
        <group>Boxcar</group>
        <limit>
          <label>Std Dev Boxcar</label>
          <symbol>Urms</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Pwr" index="0" module="sweeper">
        <power>true</power>
        <display>Power</display>
        <variable>pwr</variable>
        <group>Boxcar</group>
        <limit>
          <label>Pwr Boxcar</label>
          <symbol>U&#178;avg</symbol>
          <unit>${sourceUnit}</unit> <!-- will be squared due to 'power' -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="BWN" index="0" module="sweeper">
        <display>Amplitude</display>
        <variable>value</variable>
        <group>Boxcar</group>
        <limit>
          <label>Boxcar</label>
          <symbol>Amplitude</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="RmsBWN" index="0" module="sweeper">
        <display>Std Deviation</display>
        <variable>stddev</variable>
        <group>Boxcar</group>
        <limit>
          <label>Std Dev Boxcar</label>
          <symbol>Urms</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="PwrBWN" index="0" module="sweeper">
        <power>true</power>
        <display>Power</display>
        <variable>pwr</variable>
        <group>Boxcar</group>
        <limit>
          <label>Pwr Boxcar</label>
          <symbol>U&#178;avg</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit> <!-- will be squared due to 'power' -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Cal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Amplitude</display>
        <variable>value</variable>
        <group>Boxcar</group>
        <limit>
          <label>Norm Boxcar</label>
          <symbol>Uavg/Uref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="RmsCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Deviation</display>
        <variable>stddev</variable>
        <group>Boxcar</group>
        <limit>
          <label>Norm Std Dev Boxcar</label>
          <symbol>Urms/Urmsref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="PwrCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Power</display>
        <variable>pwr</variable>
        <group>Boxcar</group>
        <limit>
          <label>Norm Pwr Boxcar</label>
          <symbol>U&#178;avg/U&#178;ref</symbol>
          <unit>V/V</unit> <!-- will be squared due to 'power' --> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="BWNCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Amplitude</display>
        <variable>value</variable>
        <group>Boxcar</group>
        <limit>
          <label>Norm Boxcar</label>
          <symbol>Uavg/Uref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="RmsBWNCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Deviation</display>
        <variable>stddev</variable>
        <group>Boxcar</group>
        <limit>
          <label>Norm Std Dev Boxcar</label>
          <symbol>Urms/Urmsref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="PwrBWNCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Power</display>
        <variable>pwr</variable>
        <group>Boxcar</group>
        <limit>
          <label>Norm Pwr Boxcar</label>
          <symbol>U&#178;avg/U&#178;ref</symbol>
          <unit>V/V</unit> <!-- will be squared due to 'power' --> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
    </signalGroup>
  </leafRule>

  <leafRule match="/dev[0-9]+/boxcars/([0-9]+)/windowsize">
    <dataType>double</dataType>
    <display>BOX ${p1+1} Window Size</display>
    <treeDisplay>Window Size</treeDisplay>
    <limit>
      <label>BOX Window Size</label>
      <symbol>&#920;</symbol>
      <unit>deg</unit>
      <pmin>0</pmin>
      <pmax>360</pmax>
      <mapping>LINEAR</mapping>
    </limit>
    <unitCalcSelector>RAW</unitCalcSelector>
  </leafRule>

  <leafRule match="/dev[0-9]+/boxcars/([0-9]+)/windowstart">
    <dataType>double</dataType>
    <display>BOX ${p1+1} Window Start</display>
    <treeDisplay>Window Start</treeDisplay>
    <limit>
      <label>BOX Window Start</label>
      <symbol>&#920;</symbol>
      <unit>deg</unit>
      <pmin>0</pmin>
      <pmax>360</pmax>
      <mapping>LINEAR</mapping>
    </limit>
    <unitCalcSelector>RAW</unitCalcSelector>
  </leafRule>

  <leafRule match="/dev[0-9]+/boxcars/([0-9]+)/averagerbandwidth">
    <dataType>double</dataType>
    <display>Averager Bandwidth</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/boxcars/([0-9]+)/baseline">
    <display>Baseline</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/boxcars/([0-9]+)/baseline/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/boxcars/([0-9]+)/baseline/windowstart">
    <dataType>double</dataType>
    <display>Window Start</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/boxcars/([0-9]+)/decimation">
    <dataType>int</dataType>
    <display>Decimation</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/boxcars/([0-9]+)/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/boxcars/([0-9]+)/fifooverflow">
    <dataType>int</dataType>
    <display>FIFO Overflow</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/boxcars/([0-9]+)/freqoverflow">
    <dataType>int</dataType>
    <display>Frequency Overflow</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/boxcars/([0-9]+)/inputselect">
    <dataType>int</dataType>
    <display>Input Selection</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/boxcars/([0-9]+)/limitrate">
    <dataType>double</dataType>
    <display>Rate Limit</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/boxcars/([0-9]+)/oscselect">
    <dataType>int</dataType>
    <display>Oscillator Selection</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/boxcars/([0-9]+)/overflow">
    <dataType>int</dataType>
    <display>Overflow</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/boxcars/([0-9]+)/periodoverflowevents">
    <dataType>int</dataType>
    <display>Periodic Overflow Events</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/boxcars/([0-9]+)/periods">
    <dataType>int</dataType>
    <display>Periods</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/boxcars/([0-9]+)/rate">
    <dataType>double</dataType>
    <display>Sampling Rate</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/boxcars/([0-9]+)/value">
    <dataType>double</dataType>
    <display>Boxcar ${p1+1}</display>
    <treeDisplay>Value</treeDisplay>
    <group>Boxcar</group>
    <limit>
      <label>Boxcar</label>
      <symbol>U</symbol>
      <unit>${sourceUnit}</unit>
      <pmin>-2.0</pmin>
      <pmax>2.0</pmax>
      <mapping>LINEAR</mapping>
    </limit>
    <unitCalcSelector>BOXCAR</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
    <signal>Amplitude</signal>
  </leafRule>

<!-- cnts -->

  <branchRule match="/dev[0-9]+/cnts">
    <display>Pulse Counters</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/cnts/([0-9]+)/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/cnts/([0-9]+)/gateselect">
    <dataType>int</dataType>
    <display>Gate</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/cnts/([0-9]+)/inputselect">
    <dataType>int</dataType>
    <display>Input</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/cnts/([0-9]+)/integrate">
    <dataType>int</dataType>
    <display>Integrate</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/cnts/([0-9]+)/mode">
    <dataType>int</dataType>
    <display>Mode</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/cnts/([0-9]+)/operation">
    <dataType>int</dataType>
    <display>Operation</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/cnts/([0-9]+)/period">
    <dataType>double</dataType>
    <display>Period</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/cnts/([0-9]+)/trigfalling">
    <dataType>int</dataType>
    <display>Falling Edge Trigger</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/cnts/([0-9]+)/trigrising">
    <dataType>int</dataType>
    <display>Rising Edge Trigger</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/cnts/([0-9]+)/value">
    <dataType>int</dataType>
    <display>Value</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/cnts/([0-9]+)">
    <display>Counter ${p1+1}</display>
    <unitCalcSelector>RAW</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
  </branchRule>

  <leafRule match="/dev[0-9]+/cnts/([0-9]+)/sample">
    <dataType>sample</dataType>
    <display>Counter ${p1+1} Sample</display>
    <treeDisplay>Pulse Count</treeDisplay>
    <variable>value</variable>
    <group>Pulse Count</group>
    <limit>
      <label>Pulse Count</label>
      <symbol>&#35;</symbol>
      <unit></unit>
      <pmin>0</pmin>
      <pmax>1e6</pmax>
      <mapping>LINEAR</mapping>
    </limit>
    <unitCalcSelector>RAW</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
    <signal>Amplitude</signal>
    <signalGroup>
      <signalRule name="Rms" index="0" module="sweeper">
        <display>Std Deviation</display>
        <variable>stddev</variable>
        <group>Pulse Count</group>
        <limit>
          <label>Std Dev Pulse Count</label>
          <symbol>stddev &#35;</symbol>
          <unit></unit>
          <pmin>0</pmin>
          <pmax>1e6</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Pwr" index="0" module="sweeper">
        <power>true</power>
        <display>Power</display>
        <variable>pwr</variable>
        <group>Pulse Count</group>
        <limit>
          <label>Pwr Pulse Count</label>
          <symbol>pwr &#35;</symbol>
          <unit></unit>
          <!-- will be squared due to 'power' -->
          <pmin>0</pmin>
          <pmax>1e6</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Cal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Pulse Count</display>
        <variable>value</variable>
        <group>Pulse Count</group>
        <limit>
          <label>Norm Pulse Count</label>
          <symbol>norm &#35;</symbol>
          <unit></unit>
          <!-- TODO(2K): See note for units at the top -->
          <pmin>0.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="RmsCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Deviation</display>
        <variable>stddev</variable>
        <group>Pulse Count</group>
        <limit>
          <label>Norm Std Dev Pulse Count</label>
          <symbol>norm stddev &#35;</symbol>
          <unit></unit>
          <!-- TODO(2K): See note for units at the top -->
          <pmin>0.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="PwrCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Power</display>
        <variable>pwr</variable>
        <group>Pulse Count</group>
        <limit>
          <label>Norm Pwr Pulse Count</label>
          <symbol>norm pwr &#35;</symbol>
          <unit></unit>
          <!-- will be squared due to 'power' -->
          <!-- TODO(2K): See note for units at the top -->
          <pmin>0.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
    </signalGroup>
  </leafRule>

<!-- demods -->

  <branchRule match="/dev[0-9]+/demods">
    <display>Demodulators</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/demods/([0-9]+)">
    <display>Demodulator ${p1+1}</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/demods/([0-9]+)/phaseshift">
    <dataType>double</dataType>
    <display>Demod ${p1+1} Phase Shift</display>
    <treeDisplay>Phase Shift</treeDisplay>
    <limit>
      <label>Phase</label>
      <symbol>&#920;</symbol>
      <unit>deg</unit>
      <pmin>0</pmin>
      <pmax>360</pmax>
      <mapping>LINEAR</mapping>
    </limit>
    <unitCalcSelector>RAW</unitCalcSelector>
  </leafRule>

  <leafRule match="/dev[0-9]+/demods/([0-9]+)/sample">
    <dataType>sample</dataType>
    <display>Demod ${p1+1} Sample</display>
    <treeDisplay>Sample</treeDisplay>
    <unitCalcSelector>DEMOD</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
    <signalGroup>
      <!-- index attribute decides actual demod sample field: hard coded in ziCore / DAQNode.hpp / selectSignal -->
      <signalRule name="X" index="0">
        <display>Demod ${p1+1} X</display>
        <treeDisplay>X</treeDisplay>
        <variable>x</variable>
        <group>Amplitude</group>
        <limit>
          <label>Amplitude</label>
          <symbol>X</symbol> <!-- TODO(2K): For sweeper it was 'Xavg'. Is it important? -->
          <unit>${sourceUnit}</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <scopeIndex>${p1+16}</scopeIndex>
      </signalRule>
      <signalRule name="Y" index="1">
        <display>Demod ${p1+1} Y</display>
        <treeDisplay>Y</treeDisplay>
        <variable>y</variable>
        <group>Amplitude</group>
        <limit>
          <label>Amplitude</label>
          <symbol>Y</symbol> <!-- TODO(2K): For sweeper it was 'Yavg'. Is it important? -->
          <unit>${sourceUnit}</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <scopeIndex>${p1+32}</scopeIndex>
      </signalRule>
      <signalRule name="R" index="2">
        <display>Demod ${p1+1} R</display>
        <treeDisplay>R</treeDisplay>
        <variable>r</variable>
        <group>Amplitude</group>
        <limit>
          <label>Amplitude</label>
          <symbol>R</symbol> <!-- TODO(2K): For sweeper it was 'Ravg'. Is it important? -->
          <unit>${sourceUnit}</unit>
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <scopeIndex>${p1+48}</scopeIndex>
      </signalRule>
      <signalRule name="Theta" index="3">
        <display>Demod ${p1+1} Phase</display>
        <treeDisplay>Phase</treeDisplay>
        <variable>phase</variable>
        <group>Phase</group>
        <limit>
          <label>Phase</label>
          <symbol>&#920;</symbol> <!-- TODO(2K): For sweeper it was '&#920;avg'. Is it important? -->
          <unit>rad</unit>
          <pmin>-PI</pmin>
          <pmax>PI</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <scopeIndex>${p1+64}</scopeIndex>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="Frequency" index="4">
        <display>Demod ${p1+1} Freq</display>
        <treeDisplay>Frequency</treeDisplay>
        <variable>frequency</variable>
        <group>Frequency</group>
        <limit>
          <label>Osc Frequency</label>
          <symbol>f</symbol> <!-- TODO(2K): For sweeper it was 'favg'. Is it important? -->
          <unit>Hz</unit>
          <pmin>0.0</pmin>
          <pmax>1.8e9</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="AuxIn0" index="6">
        <display>Demod ${p1+1} Aux In 1</display>
        <treeDisplay>Aux In 1</treeDisplay>
        <variable>auxin0</variable>
        <group>Aux In</group>
        <limit>
          <label>Aux In</label>
          <symbol>In1</symbol> <!-- TODO(2K): For sweeper it was 'Uavg'. Is it important? -->
          <unit>V</unit>
          <pmin>-10.0</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="AuxIn1" index="7">
        <display>Demod ${p1+1} Aux In 2</display>
        <treeDisplay>Aux In 2</treeDisplay>
        <variable>auxin1</variable>
        <group>Aux In</group>
        <limit>
          <label>Aux In</label>
          <symbol>In2</symbol> <!-- TODO(2K): For sweeper it was 'Uavg'. Is it important? -->
          <unit>V</unit>
          <pmin>-10.0</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="Dio" index="8">
        <display>Demod ${p1+1} Dio</display>
        <treeDisplay>DIO</treeDisplay>
        <variable>dio</variable>
        <group>Dio</group>
        <limit>
          <label>Dio</label>
          <symbol>Dio</symbol>
          <unit></unit>
          <pmin>0.0</pmin>
          <pmax>65535.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!-- #7453 - HW Trigger as all bits together disabled
      <signalRule name="Trigger" index="9">
        <display>Demod ${p1+1} HW Trigger</display>
        <treeDisplay>HW Trigger</treeDisplay>
        <variable>hwtrigger</variable>
        <group>HW Trigger</group>
        <limit>
          <label>HW Trigger</label>
          <symbol>Trig</symbol>
          <unit></unit>
          <pmin>0.0</pmin>
          <pmax>15.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
-->
      <signalRule name="TrigIn3" index="100" devicetype="UHF">
        <display>Demod ${p1+1} Trig In 3</display>
        <treeDisplay>Trig In 3</treeDisplay>
        <group>HW Trigger</group>
        <limit>
          <label>HW Trigger</label>
          <symbol>Trig</symbol>
          <unit></unit>
          <pmin>0.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="TrigIn4" index="101" devicetype="UHF">
        <display>Demod ${p1+1} Trig In 4</display>
        <treeDisplay>Trig In 4</treeDisplay>
        <group>HW Trigger</group>
        <limit>
          <label>HW Trigger</label>
          <symbol>Trig</symbol>
          <unit></unit>
          <pmin>0.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="TrigIn1" index="102" devicetype="UHF|MF">
        <display>Demod ${p1+1} Trig In 1</display>
        <treeDisplay>Trig In 1</treeDisplay>
        <group>HW Trigger</group>
        <limit>
          <label>HW Trigger</label>
          <symbol>Trig</symbol>
          <unit></unit>
          <pmin>0.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="TrigIn2" index="103" devicetype="UHF|MF">
        <display>Demod ${p1+1} Trig In 2</display>
        <treeDisplay>Trig In 2</treeDisplay>
        <group>HW Trigger</group>
        <limit>
          <label>HW Trigger</label>
          <symbol>Trig</symbol>
          <unit></unit>
          <pmin>0.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="TrigOut3" index="104" devicetype="UHF">
        <display>Demod ${p1+1} Trig Out 3</display>
        <treeDisplay>Trig Out 3</treeDisplay>
        <group>HW Trigger</group>
        <limit>
          <label>HW Trigger</label>
          <symbol>Trig</symbol>
          <unit></unit>
          <pmin>0.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="TrigOut4" index="105" devicetype="UHF">
        <display>Demod ${p1+1} Trig Out 4</display>
        <treeDisplay>Trig Out 4</treeDisplay>
        <group>HW Trigger</group>
        <limit>
          <label>HW Trigger</label>
          <symbol>Trig</symbol>
          <unit></unit>
          <pmin>0.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="TrigOut1" index="106" devicetype="UHF|MF">
        <display>Demod ${p1+1} Trig Out 1</display>
        <treeDisplay>Trig Out 1</treeDisplay>
        <group>HW Trigger</group>
        <limit>
          <label>HW Trigger</label>
          <symbol>Trig</symbol>
          <unit></unit>
          <pmin>0.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="TrigOut2" index="107" devicetype="UHF|MF">
        <display>Demod ${p1+1} Trig Out 2</display>
        <treeDisplay>Trig Out 2</treeDisplay>
        <group>HW Trigger</group>
        <limit>
          <label>HW Trigger</label>
          <symbol>Trig</symbol>
          <unit></unit>
          <pmin>0.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="TrigDemod4Phase" index="108" devicetype="UHF">
        <display>Demod ${p1+1} Trig Demod 4 Phase</display>
        <treeDisplay>Trig Demod 4 Phase</treeDisplay>
        <group>HW Trigger</group>
        <limit>
          <label>HW Trigger</label>
          <symbol>Trig</symbol>
          <unit></unit>
          <pmin>0.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="TrigDemod8Phase" index="109" devicetype="UHF">
        <display>Demod ${p1+1} Trig Demod 8 Phase</display>
        <treeDisplay>Trig Demod 8 Phase</treeDisplay>
        <group>HW Trigger</group>
        <limit>
          <label>HW Trigger</label>
          <symbol>Trig</symbol>
          <unit></unit>
          <pmin>0.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="TrigDemod1Phase" index="108" devicetype="MF">
        <display>Demod ${p1+1} Trig Demod 1 Phase</display>
        <treeDisplay>Trig Demod 1 Phase</treeDisplay>
        <group>HW Trigger</group>
        <limit>
          <label>HW Trigger</label>
          <symbol>Trig</symbol>
          <unit></unit>
          <pmin>0.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="TrigDemod2Phase" index="109" devicetype="MF" deviceoption="MD">
        <display>Demod ${p1+1} Trig Demod 2 Phase</display>
        <treeDisplay>Trig Demod 2 Phase</treeDisplay>
        <group>HW Trigger</group>
        <limit>
          <label>HW Trigger</label>
          <symbol>Trig</symbol>
          <unit></unit>
          <pmin>0.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="TrigAWGTrig1" index="110" devicetype="UHF">
        <display>Demod ${p1+1} AWG Trigger 1</display>
        <treeDisplay>AWG Trigger 1</treeDisplay>
        <group>HW Trigger</group>
        <limit>
          <label>HW Trigger</label>
          <symbol>Trig</symbol>
          <unit></unit>
          <pmin>0.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="TrigAWGTrig2" index="111" devicetype="UHF">
        <display>Demod ${p1+1} AWG Trigger 2</display>
        <treeDisplay>AWG Trigger 2</treeDisplay>
        <group>HW Trigger</group>
        <limit>
          <label>HW Trigger</label>
          <symbol>Trig</symbol>
          <unit></unit>
          <pmin>0.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="TrigAWGTrig3" index="112" devicetype="UHF">
        <display>Demod ${p1+1} AWG Trigger 3</display>
        <treeDisplay>AWG Trigger 3</treeDisplay>
        <group>HW Trigger</group>
        <limit>
          <label>HW Trigger</label>
          <symbol>Trig</symbol>
          <unit></unit>
          <pmin>0.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="TrigAWGTrig4" index="113" devicetype="UHF">
        <display>Demod ${p1+1} AWG Trigger 4</display>
        <treeDisplay>AWG Trigger 4</treeDisplay>
        <group>HW Trigger</group>
        <limit>
          <label>HW Trigger</label>
          <symbol>Trig</symbol>
          <unit></unit>
          <pmin>0.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="TrigAWGMarker1" index="114" devicetype="UHF">
        <display>Demod ${p1+1} AWG Marker 1</display>
        <treeDisplay>AWG Marker 1</treeDisplay>
        <group>HW Trigger</group>
        <limit>
          <label>HW Trigger</label>
          <symbol>Trig</symbol>
          <unit></unit>
          <pmin>0.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="TrigAWGMarker2" index="115" devicetype="UHF">
        <display>Demod ${p1+1} AWG Marker 2</display>
        <treeDisplay>AWG Marker 2</treeDisplay>
        <group>HW Trigger</group>
        <limit>
          <label>HW Trigger</label>
          <symbol>Trig</symbol>
          <unit></unit>
          <pmin>0.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="TrigAWGMarker3" index="116" devicetype="UHF">
        <display>Demod ${p1+1} AWG Marker 3</display>
        <treeDisplay>AWG Marker 3</treeDisplay>
        <group>HW Trigger</group>
        <limit>
          <label>HW Trigger</label>
          <symbol>Trig</symbol>
          <unit></unit>
          <pmin>0.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="TrigAWGMarker4" index="117" devicetype="UHF">
        <display>Demod ${p1+1} AWG Marker 4</display>
        <treeDisplay>AWG Marker 4</treeDisplay>
        <group>HW Trigger</group>
        <limit>
          <label>HW Trigger</label>
          <symbol>Trig</symbol>
          <unit></unit>
          <pmin>0.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="TrigAWGSeq" index="118" devicetype="UHF" deviceoption="AWG">
        <display>Demod ${p1+1} Trig AWG Seq Index</display>
        <treeDisplay>Trig AWG Seq Index</treeDisplay>
        <group>HW Trigger AWG Seq Index</group>
        <limit>
          <label>HW Trigger AWG Seq Index</label>
          <symbol>Trig</symbol>
          <unit>LSBs</unit>
          <pmin>0.0</pmin>
          <pmax>16384.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>

      <!-- sweeper derived signals -->
      <signalRule name="XRms" index="0" module="sweeper">
        <display>Std Deviation X</display>
        <variable>xstddev</variable>
        <group>Amplitude</group>
        <limit>
          <label>Std Deviation</label>
          <symbol>Xrms</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="YRms" index="0" module="sweeper">
        <display>Std Deviation Y</display>
        <variable>ystddev</variable>
        <group>Amplitude</group>
        <limit>
          <label>Std Deviation</label>
          <symbol>Yrms</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="RRms" index="0" module="sweeper">
        <display>Std Deviation R</display>
        <variable>rstddev</variable>
        <group>Amplitude</group>
        <limit>
          <label>Std Deviation</label>
          <symbol>Rrms</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="ThetaRms" index="0" module="sweeper">
        <display>Phase Noise</display>
        <variable>phasestddev</variable>
        <group>Phase</group>
        <limit>
          <label>Phase Noise</label>
          <symbol>&#920;rms</symbol>
          <unit>rad</unit>
          <pmin>1e-12</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="FreqRms" index="0" module="sweeper">
        <display>Osc Frequency Noise</display>
        <variable>frequencystddev</variable>
        <group>Frequency</group>
        <limit>
          <label>Osc Frequency Noise</label>
          <symbol>frms</symbol>
          <unit>Hz</unit>
          <pmin>1e-9</pmin>
          <pmax>1e3</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="AuxIn0Rms" index="0" module="sweeper">
        <display>Std Dev Aux In 1</display>
        <variable>auxin0stddev</variable>
        <group>Aux In</group>
        <limit>
          <label>Std Dev Aux In</label>
          <symbol>Urms</symbol>
          <unit>V</unit>
          <pmin>1e-12</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="AuxIn1Rms" index="0" module="sweeper">
        <display>Std Dev Aux In 2</display>
        <variable>auxin1stddev</variable>
        <group>Aux In</group>
        <limit>
          <label>Std Dev Aux In</label>
          <symbol>Urms</symbol>
          <unit>V</unit>
          <pmin>1e-12</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>

      <signalRule name="XPwr" index="0" module="sweeper">
        <power>true</power>
        <display>Power X</display>
        <variable>xpwr</variable>
        <group>Amplitude</group>
        <limit>
          <label>Power</label>
          <symbol>X&#178;avg</symbol>
          <unit>${sourceUnit}</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-12</pmin>
          <pmax>4.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="YPwr" index="0" module="sweeper">
        <power>true</power>
        <display>Power Y</display>
        <variable>ypwr</variable>
        <group>Amplitude</group>
        <limit>
          <label>Power</label>
          <symbol>Y&#178;avg</symbol>
          <unit>${sourceUnit}</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-12</pmin>
          <pmax>4.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="RPwr" index="0" module="sweeper">
        <power>true</power>
        <display>Power R</display>
        <variable>rpwr</variable>
        <group>Amplitude</group>
        <limit>
          <label>Power</label>
          <symbol>R&#178;avg</symbol>
          <unit>${sourceUnit}</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-12</pmin>
          <pmax>4.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="ThetaPwr" index="0" module="sweeper">
        <power>true</power>
        <display>Power Phase</display>
        <variable>phasepwr</variable>
        <group>Phase</group>
        <limit>
          <label>Power Phase</label>
          <symbol>&#920;&#178;avg</symbol>
          <unit>rad</unit> <!-- will be squared due to 'power' -->
          <pmin>-PI</pmin>
          <pmax>PI</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="FreqPwr" index="0" module="sweeper">
        <power>true</power>
        <display>Power Osc Frequency</display>
        <variable>frequencypwr</variable>
        <group>Frequency</group>
        <limit>
          <label>Power Osc Frequency</label>
          <symbol>f&#178;avg</symbol>
          <unit>Hz</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-3</pmin>
          <pmax>1e9</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="AuxIn0Pwr" index="0" module="sweeper">
        <power>true</power>
        <display>Pwr Aux In 1</display>
        <variable>auxin0pwr</variable>
        <group>Aux In</group>
        <limit>
          <label>Pwr Aux In</label>
          <symbol>U&#178;avg</symbol>
          <unit>V</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-12</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="AuxIn1Pwr" index="0" module="sweeper">
        <power>true</power>
        <display>Pwr Aux In 2</display>
        <variable>auxin1pwr</variable>
        <group>Aux In</group>
        <limit>
          <label>Pwr Aux In</label>
          <symbol>U&#178;avg</symbol>
          <unit>V</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-12</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>

      <signalRule name="XBWN" index="0" module="sweeper">
        <bw>true</bw>
        <display>Ampl X 1Hz BW</display>
        <variable>x</variable>
        <group>Amplitude</group>
        <limit>
          <label>Ampl 1Hz BW</label>
          <symbol>Xavg/sqrt(Hz)</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="YBWN" index="0" module="sweeper">
        <bw>true</bw>
        <display>Ampl Y 1Hz BW</display>
        <variable>y</variable>
        <group>Amplitude</group>
        <limit>
          <label>Ampl 1Hz BW</label>
          <symbol>Yavg/sqrt(Hz)</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="RBWN" index="0" module="sweeper">
        <bw>true</bw>
        <display>Ampl R 1Hz BW</display>
        <variable>r</variable>
        <group>Amplitude</group>
        <limit>
          <label>Ampl 1Hz BW</label>
          <symbol>Ravg/sqrt(Hz)</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="ThetaBWN" index="0" module="sweeper">
        <bw>true</bw>
        <display>Phase 1Hz BW</display>
        <variable>phase</variable>
        <group>Phase</group>
        <limit>
          <label>Phase 1Hz BW</label>
          <symbol>&#920;avg/sqrt(Hz)</symbol>
          <unit>rad/Hz^0.5</unit>
          <pmin>-PI</pmin>
          <pmax>PI</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Osc frequency: BW normalization is meaningless -->
      <signalRule name="FreqBWN" index="0" module="sweeper">
        <display>Osc Frequency</display>
        <variable>frequency</variable>
        <group>Frequency</group>
        <limit>
          <label>Osc Frequency</label>
          <symbol>favg</symbol>
          <unit>Hz</unit>
          <pmin>0.0</pmin>
          <pmax>1.8e9</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Aux In 1: BW normalization is meaningless -->
      <signalRule name="AuxIn0BWN" index="0" module="sweeper">
        <display>Aux In 1</display>
        <variable>auxin0</variable>
        <group>Aux In</group>
        <limit>
          <label>Aux In</label>
          <symbol>Uavg</symbol>
          <unit>V</unit>
          <pmin>-10.0</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Aux In 2: BW normalization is meaningless -->
      <signalRule name="AuxIn1BWN" index="0" module="sweeper">
        <display>Aux In 2</display>
        <variable>auxin1</variable>
        <group>Aux In</group>
        <limit>
          <label>Aux In</label>
          <symbol>Uavg</symbol>
          <unit>V</unit>
          <pmin>-10.0</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>

      <signalRule name="XRmsBWN" index="0" module="sweeper">
        <bw>true</bw>
        <display>X Noise 1Hz BW</display>
        <variable>xstddev</variable>
        <group>Amplitude</group>
        <limit>
          <label>Noise 1Hz BW</label>
          <symbol>Xrms/sqrt(Hz)</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="YRmsBWN" index="0" module="sweeper">
        <bw>true</bw>
        <display>Y Noise 1Hz BW</display>
        <variable>ystddev</variable>
        <group>Amplitude</group>
        <limit>
          <label>Noise 1Hz BW</label>
          <symbol>Yrms/sqrt(Hz)</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="RRmsBWN" index="0" module="sweeper">
        <bw>true</bw>
        <display>R Noise 1Hz BW</display>
        <variable>rstddev</variable>
        <group>Amplitude</group>
        <limit>
          <label>Noise 1Hz BW</label>
          <symbol>Rrms/sqrt(Hz)</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="ThetaRmsBWN" index="0" module="sweeper">
        <bw>true</bw>
        <display>Phase Noise 1Hz BW</display>
        <variable>phasestddev</variable>
        <group>Phase</group>
        <limit>
          <label>Phase Noise 1Hz BW</label>
          <symbol>&#920;rms/sqrt(Hz)</symbol>
          <unit>rad/Hz^0.5</unit>
          <pmin>1e-12</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Osc frequency: BW normalization is meaningless -->
      <signalRule name="FreqRmsBWN" index="0" module="sweeper">
        <display>Osc Frequency Noise</display>
        <variable>frequencystddev</variable>
        <group>Frequency</group>
        <limit>
          <label>Osc Frequency Noise</label>
          <symbol>frms</symbol>
          <unit>Hz</unit>
          <pmin>1e-9</pmin>
          <pmax>1e3</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Aux In 1: BW normalization is meaningless -->
      <signalRule name="AuxIn0RmsBWN" index="0" module="sweeper">
        <display>Std Dev Aux In 1</display>
        <variable>auxin0stddev</variable>
        <group>Aux In</group>
        <limit>
          <label>Std Dev Aux In</label>
          <symbol>Urms</symbol>
          <unit>V</unit>
          <pmin>1e-12</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Aux In 2: BW normalization is meaningless -->
      <signalRule name="AuxIn1RmsBWN" index="0" module="sweeper">
        <display>Std Dev Aux In 2</display>
        <variable>auxin1stddev</variable>
        <group>Aux In</group>
        <limit>
          <label>Std Dev Aux In</label>
          <symbol>Urms</symbol>
          <unit>V</unit>
          <pmin>1e-12</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>

      <signalRule name="XPwrBWN" index="0" module="sweeper">
        <bw>true</bw>
        <power>true</power>
        <display>Power X 1Hz BW</display>
        <variable>xpwr</variable>
        <group>Amplitude</group>
        <limit>
          <label>Power 1Hz BW</label>
          <symbol>X&#178;avg/Hz</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit> <!-- will be squared due to 'power' -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="YPwrBWN" index="0" module="sweeper">
        <bw>true</bw>
        <power>true</power>
        <display>Power Y 1Hz BW</display>
        <variable>ypwr</variable>
        <group>Amplitude</group>
        <limit>
          <label>Power 1Hz BW</label>
          <symbol>Y&#178;avg/Hz</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit> <!-- will be squared due to 'power' -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="RPwrBWN" index="0" module="sweeper">
        <bw>true</bw>
        <power>true</power>
        <display>Power R 1Hz BW</display>
        <variable>rpwr</variable>
        <group>Amplitude</group>
        <limit>
          <label>Power 1Hz BW</label>
          <symbol>R&#178;avg/Hz</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="ThetaPwrBWN" index="0" module="sweeper">
        <bw>true</bw>
        <power>true</power>
        <display>Power Phase 1Hz BW</display>
        <variable>phasepwr</variable>
        <group>Phase</group>
        <limit>
          <label>Power Phase 1Hz BW</label>
          <symbol>&#920;avg/Hz</symbol>
          <unit>rad/Hz^0.5</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-12</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Osc frequency: BW normalization is meaningless -->
      <signalRule name="FreqPwrBWN" index="0" module="sweeper">
        <power>true</power>
        <display>Power Osc Frequency</display>
        <variable>frequencypwr</variable>
        <group>Frequency</group>
        <limit>
          <label>Power Osc Frequency</label>
          <symbol>f&#178;avg</symbol>
          <unit>Hz</unit>  <!-- will be squared due to 'power' -->
          <pmin>1e-3</pmin>
          <pmax>1e9</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Aux In 1: BW normalization is meaningless -->
      <signalRule name="AuxIn0PwrBWN" index="0" module="sweeper">
        <power>true</power>
        <display>Pwr Aux In 1</display>
        <variable>auxin0pwr</variable>
        <group>Aux In</group>
        <limit>
          <label>Pwr Aux In</label>
          <symbol>U&#178;avg</symbol>
          <unit>V</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-12</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Aux In 2: BW normalization is meaningless -->
      <signalRule name="AuxIn1PwrBWN" index="0" module="sweeper">
        <power>true</power>
        <display>Pwr Aux In 2</display>
        <variable>auxin1pwr</variable>
        <group>Aux In</group>
        <limit>
          <label>Pwr Aux In</label>
          <symbol>U&#178;avg</symbol>
          <unit>V</unit>
          <pmin>1e-12</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>

      <signalRule name="XCal" index="0" module="sweeper">
        <sweeperReferenceType>COMPLEX_X</sweeperReferenceType>
        <display>Norm Amplitude X</display>
        <variable>x</variable>
        <group>Amplitude</group>
        <limit>
          <label>Norm Amplitude</label>
          <symbol>Xavg/Xref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="YCal" index="0" module="sweeper">
        <sweeperReferenceType>COMPLEX_Y</sweeperReferenceType>
        <display>Norm Amplitude Y</display>
        <variable>y</variable>
        <group>Amplitude</group>
        <limit>
          <label>Norm Amplitude</label>
          <symbol>Yavg/Yref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="RCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Amplitude R</display>
        <variable>r</variable>
        <group>Amplitude</group>
        <limit>
          <label>Norm Amplitude</label>
          <symbol>Ravg/Rref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="ThetaCal" index="0" module="sweeper">
        <sweeperReferenceType>SUB</sweeperReferenceType>
        <display>Norm Phase</display>
        <variable>phase</variable>
        <group>Phase</group>
        <limit>
          <label>Norm Phase</label>
          <symbol>&#920;avg-&#920;ref</symbol>
          <unit>rad</unit>
          <pmin>-PI</pmin>
          <pmax>PI</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="FreqCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Osc Frequency</display>
        <variable>frequency</variable>
        <group>Frequency</group>
        <limit>
          <label>Norm Osc Frequency</label>
          <symbol>favg/fref</symbol>
          <unit>Hz/Hz</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-3</pmin>
          <pmax>1e9</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="AuxIn0Cal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Aux In 1</display>
        <variable>auxin0</variable>
        <group>Aux In</group>
        <limit>
          <label>Norm Aux In</label>
          <symbol>Uavg/Uref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-10.0</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="AuxIn1Cal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Aux In 2</display>
        <variable>auxin1</variable>
        <group>Aux In</group>
        <limit>
          <label>Norm Aux In</label>
          <symbol>Uavg/Uref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-10.0</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>

      <signalRule name="XRmsCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Dev X</display>
        <variable>xstddev</variable>
        <group>Amplitude</group>
        <limit>
          <label>Norm Std Dev</label>
          <symbol>Xrms/Xrmsref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="YRmsCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Dev Y</display>
        <variable>ystddev</variable>
        <group>Amplitude</group>
        <limit>
          <label>Norm Std Dev</label>
          <symbol>Yrms/Yrmsref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="RRmsCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Dev R</display>
        <variable>rstddev</variable>
        <group>Amplitude</group>
        <limit>
          <label>Norm Std Dev</label>
          <symbol>Rrms/Rrmsref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="ThetaRmsCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Phase Noise</display>
        <variable>phasestddev</variable>
        <group>Phase</group>
        <limit>
          <label>Norm Phase Noise</label>
          <symbol>&#920;rms/&#920;rmsref</symbol>
          <unit>rad/rad</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="FreqRmsCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Osc Freq Noise</display>
        <variable>frequencystddev</variable>
        <group>Frequency</group>
        <limit>
          <label>Norm Osc Freq Noise</label>
          <symbol>frms/frmsref</symbol>
          <unit>Hz/Hz</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-9</pmin>
          <pmax>1e3</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="AuxIn0RmsCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Dev Aux In 1</display>
        <variable>auxin0stddev</variable>
        <group>Aux In</group>
        <limit>
          <label>Norm Std Dev Aux In</label>
          <symbol>Urms/Urmsref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="AuxIn1RmsCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Dev Aux In 2</display>
        <variable>auxin1stddev</variable>
        <group>Aux In</group>
        <limit>
          <label>Norm Std Dev Aux In</label>
          <symbol>Urms/Urmsref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>

      <signalRule name="XPwrCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Power X</display>
        <variable>xpwr</variable>
        <group>Amplitude</group>
        <limit>
          <label>Norm Power</label>
          <symbol>X&#178;avg/X&#178;ref</symbol>
          <unit>V/V</unit> <!-- will be squared due to 'power' --> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>4.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="YPwrCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Power Y</display>
        <variable>ypwr</variable>
        <group>Amplitude</group>
        <limit>
          <label>Norm Power</label>
          <symbol>Y&#178;avg/Y&#178;ref</symbol>
          <unit>V/V</unit> <!-- will be squared due to 'power' --> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>4.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="RPwrCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Power R</display>
        <variable>rpwr</variable>
        <group>Amplitude</group>
        <limit>
          <label>Norm Power</label>
          <symbol>R&#178;avg/R&#178;ref</symbol>
          <unit>V/V</unit> <!-- will be squared due to 'power' --> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>4.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Phase: Power of phase normalization is meaningless -->
      <signalRule name="ThetaPwrCal" index="0" module="sweeper">
        <sweeperReferenceType>SUB</sweeperReferenceType>
        <display>Norm Phase</display>
        <variable>phase</variable>
        <group>Phase</group>
        <limit>
          <label>Norm Phase</label>
          <symbol>&#920;avg-&#920;ref</symbol>
          <unit>rad</unit>
          <pmin>-PI</pmin>
          <pmax>PI</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="FreqPwrCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Pwr Osc Frequency</display>
        <variable>frequencypwr</variable>
        <group>Frequency</group>
        <limit>
          <label>Norm Pwr Osc Frequency</label>
          <symbol>f&#178;avg/f&#178;ref</symbol>
          <unit>Hz/Hz</unit> <!-- will be squared due to 'power' --> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-3</pmin>
          <pmax>1e9</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="AuxIn0PwrCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Pwr Aux In 1</display>
        <variable>auxin0pwr</variable>
        <group>Aux In</group>
        <limit>
          <label>Norm Pwr Aux In</label>
          <symbol>U&#178;avg/U&#178;ref</symbol>
          <unit>V/V</unit> <!-- will be squared due to 'power' --> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="AuxIn1PwrCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Pwr Aux In 2</display>
        <variable>auxin1pwr</variable>
        <group>Aux In</group>
        <limit>
          <label>Norm Pwr Aux In</label>
          <symbol>U&#178;avg/U&#178;ref</symbol>
          <unit>V/V</unit> <!-- will be squared due to 'power' --> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>

<!--   // X: Normalization not reasonable -->
      <signalRule name="XBWNCal" index="0" module="sweeper">
        <sweeperReferenceType>COMPLEX_X</sweeperReferenceType>
        <display>Norm Amplitude X</display>
        <variable>x</variable>
        <group>Amplitude</group>
        <limit>
          <label>Norm Amplitude</label>
          <symbol>Xavg/Xref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Y: Normalization not reasonable -->
      <signalRule name="YBWNCal" index="0" module="sweeper">
        <sweeperReferenceType>COMPLEX_Y</sweeperReferenceType>
        <display>Norm Amplitude Y</display>
        <variable>y</variable>
        <group>Amplitude</group>
        <limit>
          <label>Norm Amplitude</label>
          <symbol>Yavg/Yref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // R: Normalization not reasonable -->
      <signalRule name="RBWNCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Amplitude R</display>
        <variable>r</variable>
        <group>Amplitude</group>
        <limit>
          <label>Norm Amplitude</label>
          <symbol>Ravg/Rref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Theta: Normalization not reasonable -->
      <signalRule name="ThetaBWNCal" index="0" module="sweeper">
        <sweeperReferenceType>SUB</sweeperReferenceType>
        <display>Norm Phase</display>
        <variable>phase</variable>
        <group>Phase</group>
        <limit>
          <label>Norm Phase</label>
          <symbol>&#920;avg-&#920;ref</symbol>
          <unit>rad</unit>
          <pmin>-PI</pmin>
          <pmax>PI</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Freq: Normalization not reasonable -->
      <signalRule name="FreqBWNCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Osc Frequency</display>
        <variable>frequency</variable>
        <group>Frequency</group>
        <limit>
          <label>Norm Osc Frequency</label>
          <symbol>favg/fref</symbol>
          <unit>Hz/Hz</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-3</pmin>
          <pmax>1e9</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Aux In 1: BW normalization is meaningless -->
      <signalRule name="AuxIn0BWNCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Aux In 1</display>
        <variable>auxin0</variable>
        <group>Aux In</group>
        <limit>
          <label>Norm Aux In</label>
          <symbol>Uavg/Uref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-10.0</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Aux In 2: BW normalization is meaningless -->
      <signalRule name="AuxIn1BWNCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Aux In 2</display>
        <variable>auxin1</variable>
        <group>Aux In</group>
        <limit>
          <label>Norm Aux In</label>
          <symbol>Uavg/Uref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-10.0</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>

<!--   // X: Normalization not reasonable -->
      <signalRule name="XRmsBWNCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Dev X</display>
        <variable>xstddev</variable>
        <group>Amplitude</group>
        <limit>
          <label>Norm Std Dev</label>
          <symbol>Xrms/Xrmsref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Y: Normalization not reasonable -->
      <signalRule name="YRmsBWNCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Dev Y</display>
        <variable>ystddev</variable>
        <group>Amplitude</group>
        <limit>
          <label>Norm Std Dev</label>
          <symbol>Yrms/Yrmsref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // R: Normalization not reasonable -->
      <signalRule name="RRmsBWNCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Dev R</display>
        <variable>rstddev</variable>
        <group>Amplitude</group>
        <limit>
          <label>Norm Std Dev</label>
          <symbol>Rrms/Rrmsref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Theta: Normalization not reasonable -->
      <signalRule name="ThetaRmsBWNCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Phase Noise</display>
        <variable>phasestddev</variable>
        <group>Phase</group>
        <limit>
          <label>Norm Phase Noise</label>
          <symbol>&#920;rms/&#920;rmsref</symbol>
          <unit>rad/rad</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Freq: Normalization not reasonable -->
      <signalRule name="FreqRmsBWNCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Osc Freq Noise</display>
        <variable>frequencystddev</variable>
        <group>Frequency</group>
        <limit>
          <label>Norm Osc Freq Noise</label>
          <symbol>frms/frmsref</symbol>
          <unit>Hz/Hz</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-9</pmin>
          <pmax>1e3</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Aux In 1: BW normalization is meaningless -->
      <signalRule name="AuxIn0RmsBWNCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Dev Aux In 1</display>
        <variable>auxin0stddev</variable>
        <group>Aux In</group>
        <limit>
          <label>Norm Std Dev Aux In</label>
          <symbol>Urms/Urmsref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Aux In 2: BW normalization is meaningless -->
      <signalRule name="AuxIn1RmsBWNCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Dev Aux In 2</display>
        <variable>auxin1stddev</variable>
        <group>Aux In</group>
        <limit>
          <label>Norm Std Dev Aux In</label>
          <symbol>Urms/Urmsref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>

<!--   // X: Normalization not reasonable -->
      <signalRule name="XPwrBWNCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Power X</display>
        <variable>xpwr</variable>
        <group>Amplitude</group>
        <limit>
          <label>Norm Power</label>
          <symbol>X&#178;avg/X&#178;ref</symbol>
          <unit>V/V</unit> <!-- will be squared due to 'power' --> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>4.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Y: Normalization not reasonable -->
      <signalRule name="YPwrBWNCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Power Y</display>
        <variable>ypwr</variable>
        <group>Amplitude</group>
        <limit>
          <label>Norm Power</label>
          <symbol>Y&#178;avg/Y&#178;ref</symbol>
          <unit>V/V</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-12</pmin>
          <pmax>4.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // R: Normalization not reasonable -->
      <signalRule name="RPwrBWNCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Power R</display>
        <variable>rpwr</variable>
        <group>Amplitude</group>
        <limit>
          <label>Norm Power</label>
          <symbol>R&#178;avg/R&#178;ref</symbol>
          <unit>V/V</unit> <!-- will be squared due to 'power' --> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>4.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Phase: Power of phase is meaningless -->
      <signalRule name="ThetaPwrBWNCal" index="0" module="sweeper">
        <sweeperReferenceType>SUB</sweeperReferenceType>
        <display>Norm Phase</display>
        <variable>phase</variable>
        <group>Phase</group>
        <limit>
          <label>Norm Phase</label>
          <symbol>&#920;avg-&#920;ref</symbol>
          <unit>rad</unit>
          <pmin>-PI</pmin>
          <pmax>PI</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Frequency: Power of frequency is meaningless -->
      <signalRule name="FreqPwrBWNCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Pwr Osc Frequency</display>
        <variable>frequencypwr</variable>
        <group>Frequency</group>
        <limit>
          <label>Norm Pwr Osc Frequency</label>
          <symbol>f&#178;avg/f&#178;ref</symbol>
          <unit>Hz/Hz</unit> <!-- will be squared due to 'power' --> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-3</pmin>
          <pmax>1e9</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Aux In 1: BW normalization is meaningless -->
      <signalRule name="AuxIn0PwrBWNCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Pwr Aux In 1</display>
        <variable>auxin0pwr</variable>
        <group>Aux In</group>
        <limit>
          <label>Norm Pwr Aux In</label>
          <symbol>U&#178;avg/U&#178;ref</symbol>
          <unit>V/V</unit> <!-- will be squared due to 'power' --> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--   // Aux In 2: BW normalization is meaningless -->
      <signalRule name="AuxIn1PwrBWNCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Pwr Aux In 2</display>
        <variable>auxin1pwr</variable>
        <group>Aux In</group>
        <limit>
          <label>Norm Pwr Aux In</label>
          <symbol>U&#178;avg/U&#178;ref</symbol>
          <unit>V/V</unit> <!-- will be squared due to 'power' --> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>

      <!-- spectrum derived signals -->
      <signalRule name="zoomFFTXY" index="0" module="spectrum">
        <display>FFT(X+iY)</display>
        <variable>r</variable>
        <group>FFT</group>
        <limit>
          <label>FFT(X+iY)</label>
          <symbol>FFT(X+iY)</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LOG</mapping>
        </limit>
      </signalRule>
      <signalRule name="zoomFFTR" index="0" module="spectrum">
        <display>FFT(R)</display>
        <variable>r</variable>
        <group>FFT</group>
        <limit>
          <label>FFT(R)</label>
          <symbol>FFT(R)</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>1e-12</pmin>
          <pmax>1e-3</pmax>
          <mapping>LOG</mapping>
        </limit>
      </signalRule>
      <signalRule name="zoomFFTTheta" index="0" module="spectrum">
        <display>FFT(&#x398;)</display>
        <variable>r</variable>
        <group>FFT</group>
        <limit>
          <label>FFT(&#x398;)</label>
          <symbol>FFT(&#x398;)</symbol>
          <unit>rad</unit>
          <pmin>1e-6</pmin>
          <pmax>PI</pmax>
          <mapping>LOG</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="zoomFFTFreq" index="0" module="spectrum">
        <display>FFT(f)</display>
        <variable>r</variable>
        <group>FFT</group>
        <limit>
          <label>FFT(f)</label>
          <symbol>FFT(f)</symbol>
          <unit>Hz</unit>
          <pmin>1e-6</pmin>
          <pmax>1.0</pmax>
          <mapping>LOG</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="zoomFFTdf" index="0" module="spectrum">
        <display>FFT(d&#x398;/dt)/(2&#x3C0;)</display>
        <variable>r</variable>
        <group>FFT</group>
        <limit>
          <label>FFT(d&#x398;/dt)/(2&#x3C0;)</label>
          <symbol>FFT(d&#x398;/dt)/(2&#x3C0;)</symbol>
          <unit>Hz</unit>
          <pmin>1e-6</pmin>
          <pmax>100.0</pmax>
          <mapping>LOG</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="zoomFFTBWNXY" index="0" module="spectrum">
        <bw>true</bw>
        <display>Spectral Density FFT(X+iY)</display>
        <variable>r</variable>
        <group>FFT</group>
        <limit>
          <label>Spectral Density FFT(X+iY)</label>
          <symbol>FFT(X+iY)/sqrt(Hz)</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LOG</mapping>
        </limit>
      </signalRule>
      <signalRule name="zoomFFTBWNR" index="0" module="spectrum">
        <bw>true</bw>
        <display>Spectral Density FFT(R)</display>
        <variable>r</variable>
        <group>FFT</group>
        <limit>
          <label>Spectral Density FFT(R)</label>
          <symbol>FFT(R)/sqrt(Hz)</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>1e-12</pmin>
          <pmax>1e-3</pmax>
          <mapping>LOG</mapping>
        </limit>
      </signalRule>
      <signalRule name="zoomFFTBWNTheta" index="0" module="spectrum">
        <bw>true</bw>
        <display>Spectral Density FFT(&#x398;)</display>
        <variable>r</variable>
        <group>FFT</group>
        <limit>
          <label>Spectral Density FFT(&#x398;)</label>
          <symbol>FFT(&#x398;)/sqrt(Hz)</symbol>
          <unit>rad/Hz^0.5</unit>
          <pmin>1e-6</pmin>
          <pmax>PI</pmax>
          <mapping>LOG</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="zoomFFTBWNFreq" index="0" module="spectrum">
        <bw>true</bw>
        <display>Spectral Density FFT(f)</display>
        <variable>r</variable>
        <group>FFT</group>
        <limit>
          <label>Spectral Density FFT(f)</label>
          <symbol>FFT(f)/sqrt(Hz)</symbol>
          <unit>Hz/Hz^0.5</unit>
          <pmin>1e-6</pmin>
          <pmax>1.0</pmax>
          <mapping>LOG</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="zoomFFTBWNdf" index="0" module="spectrum">
        <bw>true</bw>
        <display>Spectral Density FFT(d&#x398;/dt)/(2&#x3C0;)</display>
        <variable>r</variable>
        <group>FFT</group>
        <limit>
          <label>Spectral Density FFT(d&#x398;/dt)/(2&#x3C0;)</label>
          <symbol>FFT(d&#x398;/dt)/(2&#x3C0;)/sqrt(Hz)</symbol>
          <unit>Hz/Hz^0.5</unit>
          <pmin>1e-6</pmin>
          <pmax>1000.0</pmax>
          <mapping>LOG</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="zoomFFTPwrXY" index="0" module="spectrum">
        <power>true</power>
        <display>Power FFT(X+iY)</display>
        <variable>r</variable>
        <group>FFT</group>
        <limit>
          <label>Power FFT(X+iY)</label>
          <symbol>FFT(X+iY)&#xB2;</symbol>
          <unit>${sourceUnit}</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-24</pmin>
          <pmax>2.0</pmax>
          <mapping>LOG</mapping>
        </limit>
      </signalRule>
      <signalRule name="zoomFFTPwrR" index="0" module="spectrum">
        <power>true</power>
        <display>Power FFT(R)</display>
        <variable>r</variable>
        <group>FFT</group>
        <limit>
          <label>Power FFT(R)</label>
          <symbol>FFT(R)&#xB2;</symbol>
          <unit>${sourceUnit}</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-24</pmin>
          <pmax>1e-3</pmax>
          <mapping>LOG</mapping>
        </limit>
      </signalRule>
      <signalRule name="zoomFFTPwrTheta" index="0" module="spectrum">
        <power>true</power>
        <display>Power FFT(&#x398;)</display>
        <variable>r</variable>
        <group>FFT</group>
        <limit>
          <label>Power FFT(&#x398;)</label>
          <symbol>FFT(&#x398;)&#xB2;</symbol>
          <unit>rad</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-6</pmin>
          <pmax>PI</pmax>
          <mapping>LOG</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="zoomFFTPwrFreq" index="0" module="spectrum">
        <power>true</power>
        <display>Power FFT(f)</display>
        <variable>r</variable>
        <group>FFT</group>
        <limit>
          <label>Power FFT(f)</label>
          <symbol>FFT(f)&#xB2;</symbol>
          <unit>Hz</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-6</pmin>
          <pmax>1.0</pmax>
          <mapping>LOG</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="zoomFFTPwrdf" index="0" module="spectrum">
        <power>true</power>
        <display>Power FFT(d&#x398;/dt)/(2&#x3C0;)</display>
        <variable>r</variable>
        <group>FFT</group>
        <limit>
          <label>Power FFT(d&#x398;/dt)/(2&#x3C0;)</label>
          <symbol>FFT(d&#x398;/dt)&#xB2;/(2&#x3C0;)&#xB2;</symbol>
          <unit>Hz</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-6</pmin>
          <pmax>1000.0</pmax>
          <mapping>LOG</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="zoomFFTPwrBWNXY" index="0" module="spectrum">
        <bw>true</bw>
        <power>true</power>
        <display>Power Spectral Density FFT(X+iY)</display>
        <variable>r</variable>
        <group>FFT</group>
        <limit>
          <label>Power Spectral Density FFT(X+iY)</label>
          <symbol>FFT(X+iY)&#xB2;/Hz</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-24</pmin>
          <pmax>2.0</pmax>
          <mapping>LOG</mapping>
        </limit>
      </signalRule>
      <signalRule name="zoomFFTPwrBWNR" index="0" module="spectrum">
        <bw>true</bw>
        <power>true</power>
        <display>Power Spectral Density FFT(R)</display>
        <variable>r</variable>
        <group>FFT</group>
        <limit>
          <label>Power Spectral Density FFT(R)</label>
          <symbol>FFT(R)&#xB2;/Hz</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-24</pmin>
          <pmax>1e-3</pmax>
          <mapping>LOG</mapping>
        </limit>
      </signalRule>
      <signalRule name="zoomFFTPwrBWNTheta" index="0" module="spectrum">
        <bw>true</bw>
        <power>true</power>
        <display>Power Spectral Density FFT(&#x398;)</display>
        <variable>r</variable>
        <group>FFT</group>
        <limit>
          <label>Power Spectral Density FFT(&#x398;)</label>
          <symbol>FFT(&#x398;)/Hz</symbol>
          <unit>rad/Hz^0.5</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-6</pmin>
          <pmax>PI</pmax>
          <mapping>LOG</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="zoomFFTPwrBWNFreq" index="0" module="spectrum">
        <bw>true</bw>
        <power>true</power>
        <display>Power Spectral Density FFT(f)</display>
        <variable>r</variable>
        <group>FFT</group>
        <limit>
          <label>Power Spectral Density FFT(f)</label>
          <symbol>FFT(f)&#xB2;/Hz</symbol>
          <unit>Hz/Hz^0.5</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-6</pmin>
          <pmax>1.0</pmax>
          <mapping>LOG</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="zoomFFTPwrBWNdf" index="0" module="spectrum">
        <bw>true</bw>
        <power>true</power>
        <display>Power Spectral Density FFT(d&#x398;/dt)/(2&#x3C0;)</display>
        <variable>r</variable>
        <group>FFT</group>
        <limit>
          <label>Power Spectral Density FFT(d&#x398;/dt)/(2&#x3C0;)</label>
          <symbol>FFT(d&#x398;/dt)&#xB2;/(2&#x3C0;)&#xB2;/Hz</symbol>
          <unit>Hz/Hz^0.5</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-6</pmin>
          <pmax>1000.0</pmax>
          <mapping>LOG</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
    </signalGroup>
  </leafRule>

  <leafRule match="/dev[0-9]+/demods/([0-9]+)/adcselect">
    <dataType>int</dataType>
    <display>Input Selection</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/demods/([0-9]+)/bypass">
    <dataType>undefined</dataType>
    <display>Bypass</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/demods/([0-9]+)/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/demods/([0-9]+)/freq">
    <dataType>double</dataType>
    <display>Frequency</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/demods/([0-9]+)/harmonic">
    <dataType>int</dataType>
    <display>Harmonic</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/demods/([0-9]+)/order">
    <dataType>int</dataType>
    <display>Filter Order</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/demods/([0-9]+)/oscselect">
    <dataType>int</dataType>
    <display>Oscillator Selection</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/demods/([0-9]+)/rate">
    <dataType>double</dataType>
    <display>Sampling Rate</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/demods/([0-9]+)/sinc">
    <dataType>int</dataType>
    <display>Sinc Filter</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/demods/([0-9]+)/timeconstant">
    <dataType>double</dataType>
    <display>Filter Time Constant</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/demods/([0-9]+)/trigger">
    <dataType>int</dataType>
    <display>Trigger</display>
  </leafRule>

<!-- mods -->

  <branchRule match="/dev[0-9]+/mods">
    <display>Modulators</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/mods/([0-9]+)">
    <display>MOD ${p1+1}</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/index">
    <dataType>double</dataType>
    <display>MOD ${p1+1} Index</display>
    <treeDisplay>Index</treeDisplay>
    <limit>
      <label>MOD Index</label>
      <symbol>i</symbol>
      <unit></unit>
      <pmin>0</pmin>
      <pmax>1</pmax>
      <mapping>LINEAR</mapping>
    </limit>
    <unitCalcSelector>RAW</unitCalcSelector>
  </leafRule>

  <branchRule match="/dev[0-9]+/mods/([0-9]+)/carrier">
    <display>Carrier</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/carrier/amplitude">
    <dataType>double</dataType>
    <display>MOD ${p1+1} Carrier Amplitude</display>
    <treeDisplay>Amplitude</treeDisplay>
    <limit>
      <label>MOD Amplitude</label>
      <symbol>r</symbol>
      <unit>V</unit>
      <pmin>0</pmin>
      <pmax>1</pmax>
      <mapping>LINEAR</mapping>
    </limit>
    <unitCalcSelector>RAW</unitCalcSelector>
  </leafRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/carrier/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/carrier/harmonic">
    <dataType>int</dataType>
    <display>Harmonic</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/carrier/inputselect">
    <dataType>int</dataType>
    <display>Input Selection</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/carrier/order">
    <dataType>int</dataType>
    <display>Filter Order</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/carrier/oscselect">
    <dataType>int</dataType>
    <display>Oscillator Selection</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/carrier/phaseshift">
    <dataType>double</dataType>
    <display>Phase Shift</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/carrier/timeconstant">
    <dataType>double</dataType>
    <display>Filter Time Constant</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/mods/([0-9]+)/sidebands">
    <display>Sidebands</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/mods/([0-9]+)/sidebands/([0-9]+)">
    <display>Sideband ${p2+1}</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/sidebands/([0-9]+)/amplitude">
    <dataType>double</dataType>
    <display>MOD ${p1+1} SB ${p2+1} Amplitude</display>
    <treeDisplay>Amplitude</treeDisplay>
    <limit>
      <label>MOD Amplitude</label>
      <symbol>r</symbol>
      <unit>V</unit>
      <pmin>0</pmin>
      <pmax>1</pmax>
      <mapping>LINEAR</mapping>
    </limit>
    <unitCalcSelector>RAW</unitCalcSelector>
  </leafRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/sidebands/([0-9]+)/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/sidebands/([0-9]+)/harmonic">
    <dataType>int</dataType>
    <display>Harmonic</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/sidebands/([0-9]+)/inputselect">
    <dataType>int</dataType>
    <display>Input Selection</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/sidebands/([0-9]+)/mode">
    <dataType>int</dataType>
    <display>Mode</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/sidebands/([0-9]+)/order">
    <dataType>int</dataType>
    <display>Filter Order</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/sidebands/([0-9]+)/oscselect">
    <dataType>int</dataType>
    <display>Oscillator Selection</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/sidebands/([0-9]+)/phaseshift">
    <dataType>double</dataType>
    <display>Phase Shift</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/sidebands/([0-9]+)/timeconstant">
    <dataType>double</dataType>
    <display>Filter Time Constant</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/freqdev">
    <dataType>double</dataType>
    <display>Frequency Deviation</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/freqdevenable">
    <dataType>int</dataType>
    <display>Frequency Deviation Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/mode">
    <dataType>int</dataType>
    <display>Mode</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/operation">
    <dataType>undefined</dataType>
    <display>Operation</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/output">
    <dataType>int</dataType>
    <display>Signal Output Selection</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/rate">
    <dataType>undefined</dataType>
    <display>Sampling Rate</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/sampleenable">
    <dataType>undefined</dataType>
    <display>Sample Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/mods/([0-9]+)/trigger">
    <dataType>undefined</dataType>
    <display>Trigger</display>
  </leafRule>

<!-- oscs -->

  <branchRule match="/dev[0-9]+/oscs">
    <display>Oscillators</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/oscs/([0-9]+)">
    <display>Oscillator ${p1+1}</display>
    <scopeIndex>${p1+4}</scopeIndex> <!-- HF2 -->
    <unitCalcSelector>OSCFREQ</unitCalcSelector>
  </branchRule>

  <leafRule match="/dev[0-9]+/oscs/([0-9]+)/freq">
    <dataType>double</dataType>
    <display>Osc ${p1+1} Frequency</display>
    <treeDisplay>Frequency</treeDisplay>
    <limit>
      <label>Frequency</label>
      <symbol>f</symbol>
      <unit>Hz</unit>
      <pmin>1000</pmin>
      <pmax>1e6</pmax>
      <mapping>LOG</mapping>
    </limit>
    <unitCalcSelector>RAW</unitCalcSelector>
  </leafRule>

<!-- pids -->

  <branchRule match="/dev[0-9]+/pids">
    <display>PIDs</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/pids/([0-9]+)">
    <display>PID ${p1+1}</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/setpoint">
    <dataType>double</dataType>
    <display>PID ${p1+1} Setpoint</display>
    <treeDisplay>Setpoint</treeDisplay>
    <limit>
      <label>PID Setpoint</label>
      <symbol>s</symbol>
      <unit>${sourceUnit}</unit>
      <pmin>1000</pmin>
      <pmax>1e6</pmax>
      <mapping>LINEAR</mapping>
    </limit>
    <unitCalcSelector>PIDINPUT</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
  </leafRule>

  <branchRule match="/dev[0-9]+/pids/([0-9]+)/stream">
    <display>Streaming</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/stream/error">
    <dataType>double</dataType>
    <display>PID ${p1+1} Error</display>
    <treeDisplay>Error</treeDisplay>
    <variable>value</variable>
    <group>PID In</group>
    <limit>
      <label>Error</label>
      <symbol>U</symbol>
      <unit>${sourceUnit}</unit>
      <pmin>-2</pmin>
      <pmax>2</pmax>
      <mapping>LINEAR</mapping>
    </limit>
    <unitCalcSelector>PIDINPUT</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
    <signal>Error</signal>
    <signalGroup>
      <signalRule name="Rms" index="0" module="sweeper">
        <display>Std Deviation</display>
        <variable>stddev</variable>
        <group>PID In</group>
        <limit>
          <label>Std Dev Pid Error</label>
          <symbol>Urms</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Pwr" index="0" module="sweeper">
        <power>true</power>
        <display>Power</display>
        <variable>pwr</variable>
        <group>PID In</group>
        <limit>
          <label>Pwr Pid Error</label>
          <symbol>U&#178;avg</symbol>
          <unit>${sourceUnit}</unit> <!-- will be squared due to 'power' -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="BWN" index="0" module="sweeper">
        <display>Error</display>
        <variable>value</variable>
        <group>PID In</group>
        <limit>
          <label>Pid Error</label>
          <symbol>Amplitude</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="RmsBWN" index="0" module="sweeper">
        <display>Std Deviation</display>
        <variable>stddev</variable>
        <group>PID In</group>
        <limit>
          <label>Std Dev Pid Error</label>
          <symbol>Urms</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="PwrBWN" index="0" module="sweeper">
        <power>true</power>
        <display>Power</display>
        <variable>pwr</variable>
        <group>PID In</group>
        <limit>
          <label>Pwr Pid Error</label>
          <symbol>U&#178;avg</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit> <!-- will be squared due to 'power' -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Cal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Amplitude</display>
        <variable>value</variable>
        <group>PID In</group>
        <limit>
          <label>Norm Pid Error</label>
          <symbol>Uavg/Uref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="RmsCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Deviation</display>
        <variable>stddev</variable>
        <group>PID In</group>
        <limit>
          <label>Norm Std Dev Pid Error</label>
          <symbol>Urms/Urmsref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="PwrCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Power</display>
        <variable>pwr</variable>
        <group>PID In</group>
        <limit>
          <label>Norm Pwr Pid Error</label>
          <symbol>U&#178;avg/U&#178;ref</symbol>
          <unit>V/V</unit> <!-- will be squared due to 'power' --> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="BWNCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Amplitude</display>
        <variable>value</variable>
        <group>PID In</group>
        <limit>
          <label>Norm Pid Error</label>
          <symbol>Uavg/Uref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="RmsBWNCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Deviation</display>
        <variable>stddev</variable>
        <group>PID In</group>
        <limit>
          <label>Norm Std Dev Pid Error</label>
          <symbol>Urms/Urmsref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="PwrBWNCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Power</display>
        <variable>pwr</variable>
        <group>PID In</group>
        <limit>
          <label>Norm Pwr Pid Error</label>
          <symbol>U&#178;avg/U&#178;ref</symbol>
          <unit>V/V</unit> <!-- will be squared due to 'power' --> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
    </signalGroup>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/stream/shift">
    <dataType>double</dataType>
    <display>PID ${p1+1} Shift</display>
    <treeDisplay>Shift</treeDisplay>
    <variable>value</variable>
    <group>PID Out</group>
    <limit>
      <label>Shift</label>
      <symbol>U</symbol>
      <unit>${sourceUnit}</unit>
      <pmin>-2</pmin>
      <pmax>2</pmax>
      <mapping>LINEAR</mapping>
    </limit>
    <!-- TODO(2K): implement cascaded props -->
    <unitCalcSelector>PIDOUTPUT</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
    <signal>Shift</signal>
    <signalGroup>
      <signalRule name="Rms" index="0" module="sweeper">
        <display>Std Deviation</display>
        <variable>stddev</variable>
        <group>PID Out</group>
        <limit>
          <label>Std Dev Pid Shift</label>
          <symbol>Urms</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Pwr" index="0" module="sweeper">
        <power>true</power>
        <display>Power</display>
        <variable>pwr</variable>
        <group>PID Out</group>
        <limit>
          <label>Pwr Pid Shift</label>
          <symbol>U&#178;avg</symbol>
          <unit>${sourceUnit}</unit> <!-- will be squared due to 'power' -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="BWN" index="0" module="sweeper">
        <display>Shift</display>
        <variable>value</variable>
        <group>PID Out</group>
        <limit>
          <label>Pid Shift</label>
          <symbol>Amplitude</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="RmsBWN" index="0" module="sweeper">
        <display>Std Deviation</display>
        <variable>stddev</variable>
        <group>PID Out</group>
        <limit>
          <label>Std Dev Pid Shift</label>
          <symbol>Urms</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="PwrBWN" index="0" module="sweeper">
        <power>true</power>
        <display>Power</display>
        <variable>pwr</variable>
        <group>PID Out</group>
        <limit>
          <label>Pwr Pid Shift</label>
          <symbol>U&#178;avg</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit> <!-- will be squared due to 'power' -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Cal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Amplitude</display>
        <variable>value</variable>
        <group>PID Out</group>
        <limit>
          <label>Norm Pid Shift</label>
          <symbol>Uavg/Uref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="RmsCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Deviation</display>
        <variable>stddev</variable>
        <group>PID Out</group>
        <limit>
          <label>Norm Std Dev Pid Shift</label>
          <symbol>Urms/Urmsref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="PwrCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Power</display>
        <variable>pwr</variable>
        <group>PID Out</group>
        <limit>
          <label>Norm Pwr Pid Shift</label>
          <symbol>U&#178;avg/U&#178;ref</symbol>
          <unit>V/V</unit> <!-- will be squared due to 'power' --> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="BWNCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Amplitude</display>
        <variable>value</variable>
        <group>PID Out</group>
        <limit>
          <label>Norm Pid Shift</label>
          <symbol>Uavg/Uref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="RmsBWNCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Deviation</display>
        <variable>stddev</variable>
        <group>PID Out</group>
        <limit>
          <label>Norm Std Dev Pid Shift</label>
          <symbol>Urms/Urmsref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="PwrBWNCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Power</display>
        <variable>pwr</variable>
        <group>PID Out</group>
        <limit>
          <label>Norm Pwr Pid Shift</label>
          <symbol>U&#178;avg/U&#178;ref</symbol>
          <unit>V/V</unit> <!-- will be squared due to 'power' --> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
    </signalGroup>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/stream/value">
    <dataType>double</dataType>
    <display>PID ${p1+1} Value</display>
    <treeDisplay>Value</treeDisplay>
    <variable>value</variable>
    <group>PID Out</group>
    <limit>
      <label>Value</label>
      <symbol>U</symbol>
      <unit>${sourceUnit}</unit>
      <pmin>-2</pmin>
      <pmax>2</pmax>
      <mapping>LINEAR</mapping>
    </limit>
    <!-- TODO(2K): implement cascaded props -->
    <unitCalcSelector>PIDOUTPUT</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
    <signal>Value</signal>
    <signalGroup>
      <signalRule name="Rms" index="0" module="sweeper">
        <display>Std Deviation</display>
        <variable>value</variable>
        <group>PID Out</group>
        <limit>
          <label>Std Dev Pid Value</label>
          <symbol>Urms</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Pwr" index="0" module="sweeper">
        <power>true</power>
        <display>Power</display>
        <variable>value</variable>
        <group>PID Out</group>
        <limit>
          <label>Pwr Pid Value</label>
          <symbol>U&#178;avg</symbol>
          <unit>${sourceUnit}</unit> <!-- will be squared due to 'power' -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="BWN" index="0" module="sweeper">
        <display>Value</display>
        <variable>value</variable>
        <group>PID Out</group>
        <limit>
          <label>Pid Value</label>
          <symbol>Amplitude</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="RmsBWN" index="0" module="sweeper">
        <display>Std Deviation</display>
        <variable>value</variable>
        <group>PID Out</group>
        <limit>
          <label>Std Dev Pid Value</label>
          <symbol>Urms</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="PwrBWN" index="0" module="sweeper">
        <power>true</power>
        <display>Power</display>
        <variable>value</variable>
        <group>PID Out</group>
        <limit>
          <label>Pwr Pid Value</label>
          <symbol>U&#178;avg</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit> <!-- will be squared due to 'power' -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Cal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Amplitude</display>
        <variable>value</variable>
        <group>PID Out</group>
        <limit>
          <label>Norm Pid Value</label>
          <symbol>Uavg/Uref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="RmsCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Deviation</display>
        <variable>value</variable>
        <group>PID Out</group>
        <limit>
          <label>Norm Std Dev Pid Value</label>
          <symbol>Urms/Urmsref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="PwrCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Power</display>
        <variable>value</variable>
        <group>PID Out</group>
        <limit>
          <label>Norm Pwr Pid Value</label>
          <symbol>U&#178;avg/U&#178;ref</symbol>
          <unit>V/V</unit> <!-- will be squared due to 'power' --> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="BWNCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Amplitude</display>
        <variable>value</variable>
        <group>PID Out</group>
        <limit>
          <label>Norm Pid Value</label>
          <symbol>Uavg/Uref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="RmsBWNCal" index="0" module="sweeper">
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Deviation</display>
        <variable>value</variable>
        <group>PID Out</group>
        <limit>
          <label>Norm Std Dev Pid Value</label>
          <symbol>Urms/Urmsref</symbol>
          <unit>V/V</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="PwrBWNCal" index="0" module="sweeper">
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Power</display>
        <variable>value</variable>
        <group>PID Out</group>
        <limit>
          <label>Norm Pwr Pid Value</label>
          <symbol>U&#178;avg/U&#178;ref</symbol>
          <unit>V/V</unit> <!-- will be squared due to 'power' --> <!-- TODO(2K): See note for units at the top -->
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
    </signalGroup>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/stream/decimation">
    <dataType>int</dataType>
    <display>Decimation</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/stream/rate">
    <dataType>double</dataType>
    <display>Sampling Rate</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/center">
    <dataType>double</dataType>
    <display>Center</display>
    <!-- TODO(2K): implement cascaded props -->
    <unitCalcSelector>PIDOUTPUT</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/d">
    <dataType>double</dataType>
    <display>D</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/dlimittimeconstant">
    <dataType>double</dataType>
    <display>D Time Constant Limit</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/error">
    <dataType>double</dataType>
    <display>Error</display>
    <unitCalcSelector>PIDINPUT</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/i">
    <dataType>double</dataType>
    <display>I</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/input">
    <dataType>int</dataType>
    <display>Input Signal</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/inputchannel">
    <dataType>int</dataType>
    <display>Input Channel</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/limitlower">
    <dataType>double</dataType>
    <display>Lower Limit</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/limitupper">
    <dataType>double</dataType>
    <display>Upper Limit</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/mode">
    <dataType>int</dataType>
    <display>Mode</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/output">
    <dataType>int</dataType>
    <display>PID ${p1+1} Output</display>
    <treeDisplay>Output</treeDisplay>
    <scopeIndex>${p1+80}</scopeIndex>
    <unitCalcSelector>PIDOUTPUT</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/outputchannel">
    <dataType>int</dataType>
    <display>Output Channel</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/overflow">
    <dataType>undefined</dataType>
    <display>Overflow</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/p">
    <dataType>double</dataType>
    <display>P</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/phaseunwrap">
    <dataType>int</dataType>
    <display>Phase Unwrap</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/rate">
    <dataType>double</dataType>
    <display>Sampling Rate</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/shift">
    <dataType>double</dataType>
    <display>PID ${p1+1} Shift</display>
    <treeDisplay>Shift</treeDisplay>
    <scopeIndex>${p1+144}</scopeIndex>
    <!-- TODO(2K): implement cascaded props -->
    <unitCalcSelector>PIDOUTPUT</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/value">
    <dataType>double</dataType>
    <display>Value</display>
    <!-- TODO(2K): implement cascaded props -->
    <unitCalcSelector>PIDOUTPUT</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/monitoroffset">
    <dataType>double</dataType>
    <display>Monitor Offset</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/monitorscale">
    <dataType>double</dataType>
    <display>Monitor Scale</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/outputdefault">
    <dataType>double</dataType>
    <display>Output Default</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/outputdefaultenable">
    <dataType>int</dataType>
    <display>Output Default Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/range">
    <dataType>double</dataType>
    <display>Range</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/setpointselect">
    <dataType>int</dataType>
    <display>Setpoint Select</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/pids/([0-9]+)/tipprotect">
    <display>Tip Protect</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/tipprotect/active">
    <dataType>int</dataType>
    <display>Active</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/tipprotect/activethreshold">
    <dataType>double</dataType>
    <display>Active Threshold</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/tipprotect/activetimeconstant">
    <dataType>double</dataType>
    <display>Active Timeconstant</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/tipprotect/enable">
    <dataType>int</dataType>
    <display></display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/tipprotect/inactivethreshold">
    <dataType>double</dataType>
    <display>Inactive Threshold</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/tipprotect/inactivetimeconstant">
    <dataType>double</dataType>
    <display>Inactive Time Constant</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/pids/([0-9]+)/tipprotect/pll">
    <dataType>int</dataType>
    <display>Pll</display>
  </leafRule>


<!-- scopes -->

  <branchRule match="/dev[0-9]+/scopes">
    <display>Scopes</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/scopes/([0-9]+)">
    <display>Scope ${p1+1}</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/scopes/([0-9]+)/stream">
    <display>Streaming</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/stream/sample">
    <dataType>sample</dataType>
    <display>Sample</display>
    <unitCalcSelector>SCOPE</unitCalcSelector>
    <signalGroup>
      <!-- TODO(2K): Quick&dirty solution, limits for scope should be defined by the selected source -->
      <signalRule name="0" index="0">
        <display>Channel 1</display>
        <group>Scope</group>
        <limit>
          <label>Wave</label>
          <symbol>U</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>-1.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <featureIndex>0</featureIndex>
      </signalRule>
      <signalRule name="1" index="1">
        <display>Channel 2</display>
        <group>Scope</group>
        <limit>
          <label>Wave</label>
          <symbol>U</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>-1.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <featureIndex>1</featureIndex>
      </signalRule>
    </signalGroup>
  </leafRule>

  <branchRule match="/dev[0-9]+/scopes/([0-9]+)/stream/enables">
    <display>Enables</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/stream/enables/([0-9]+)">
    <dataType>int</dataType>
    <display>Channel ${p2+1} Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/stream/rate">
    <dataType>int</dataType>
    <display>Sampling Rate</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/channel">
    <dataType>int</dataType>
    <display>Channel</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/scopes/([0-9]+)/channels">
    <display>Channels</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/scopes/([0-9]+)/channels/([0-9]+)">
    <display>Channel ${p2+1}</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/channels/([0-9]+)/bwlimit">
    <dataType>int</dataType>
    <display>Bandwidth Limit</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/channels/([0-9]+)/fullscale">
    <dataType>double</dataType>
    <display>Full Scale</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/channels/([0-9]+)/inputselect">
    <dataType>int</dataType>
    <display>Input Signal Selection</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/channels/([0-9]+)/limitlower">
    <dataType>double</dataType>
    <display>Lower Limit</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/channels/([0-9]+)/limitupper">
    <dataType>double</dataType>
    <display>Upper Limit</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/length">
    <dataType>int</dataType>
    <display>Length</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/scopes/([0-9]+)/segments">
    <display>Segments</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/segments/count">
    <dataType>int</dataType>
    <display>Count</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/segments/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/single">
    <dataType>int</dataType>
    <display>Single</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/time">
    <dataType>int</dataType>
    <display>Time</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/trigchannel">
    <dataType>int</dataType>
    <display>Trigger Input</display>
    <unitCalcSelector>SCOPETRIGGER</unitCalcSelector>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/trigdelay">
    <dataType>double</dataType>
    <display>Trigger Delay</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/trigenable">
    <dataType>int</dataType>
    <display>Trigger Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/trigfalling">
    <dataType>int</dataType>
    <display>Falling Edge Trigger</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/trigforce">
    <dataType>int</dataType>
    <display>Force Trigger</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/scopes/([0-9]+)/triggate">
    <display>Trigger Gate</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/triggate/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/triggate/inputselect">
    <dataType>int</dataType>
    <display>Input Selection</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/trigholdoff">
    <dataType>double</dataType>
    <display>Trigger Holdoff</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/trigholdoffcount">
    <dataType>int</dataType>
    <display>Trigger Holdoff Count</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/trigholdoffmode">
    <dataType>int</dataType>
    <display>Trigger Holdoff Mode</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/scopes/([0-9]+)/trighysteresis">
    <display>Trigger Hysteresis</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/trighysteresis/absolute">
    <dataType>double</dataType>
    <display>Absolute</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/trighysteresis/mode">
    <dataType>int</dataType>
    <display>Mode</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/trighysteresis/relative">
    <dataType>double</dataType>
    <display>Relative</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/triglevel">
    <dataType>undefined</dataType> <!-- Left undefined as it is double for UHF/MF and int for HF2-->
    <display>Trigger Level</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/trigpredelay">
    <dataType>int</dataType>
    <display>Trigger Pre-Delay</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/trigreference">
    <dataType>double</dataType>
    <display>Trigger Reference</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/trigrising">
    <dataType>int</dataType>
    <display>Rising Edge Trigger</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/bwlimit">
    <dataType>int</dataType>
    <display>BW Limit</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/trigedge">
    <dataType>int</dataType>
    <display>Trigger Edge</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/scopes/([0-9]+)/wave">
    <dataType>sample</dataType>
    <display>Wave</display>
    <unitCalcSelector>SCOPE</unitCalcSelector>
    <signalGroup>
      <!-- TODO(2K): Quick&dirty solution, limits for scope should be defined by the selected source -->
      <signalRule name="0" index="0">
        <display>Ch1 Wave</display>
        <treeDisplay>Channel 1</treeDisplay>
        <group>Scope</group>
        <limit>
          <label>Wave</label>
          <symbol>U</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>-1.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <featureIndex>0</featureIndex>
      </signalRule>
      <signalRule name="0BWN" index="0">
        <display>Ch1 Spectral Density</display>
        <treeDisplay>Channel 1</treeDisplay>
        <group>Scope</group>
        <limit>
          <label>Spectral Density</label>
          <symbol>U</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>-1.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <featureIndex>0</featureIndex>
      </signalRule>
      <signalRule name="0Pwr" index="0">
        <power>true</power>
        <display>Ch1 Power</display>
        <treeDisplay>Channel 1</treeDisplay>
        <group>Scope</group>
        <limit>
          <label>Power</label>
          <symbol>U</symbol>
          <unit>${sourceUnit}</unit> <!-- will be squared due to 'power' -->
          <pmin>-1.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <featureIndex>0</featureIndex>
      </signalRule>
      <signalRule name="0PwrBWN" index="0">
        <power>true</power>
        <display>Ch1 Power Spectral Density</display>
        <treeDisplay>Channel 1</treeDisplay>
        <group>Scope</group>
        <limit>
          <label>Power Spectral Density</label>
          <symbol>U</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit> <!-- will be squared due to 'power' -->
          <pmin>-1.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <featureIndex>0</featureIndex>
      </signalRule>
      <signalRule name="1" index="1">
        <display>Ch2 Wave</display>
        <treeDisplay>Channel 2</treeDisplay>
        <group>Scope</group>
        <limit>
          <label>Wave</label>
          <symbol>U</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>-1.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <featureIndex>1</featureIndex>
      </signalRule>
      <signalRule name="1BWN" index="1">
        <display>Ch2 Spectral Density</display>
        <treeDisplay>Channel 2</treeDisplay>
        <group>Scope</group>
        <limit>
          <label>Spectral Density</label>
          <symbol>U</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>-1.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <featureIndex>1</featureIndex>
      </signalRule>
      <signalRule name="1Pwr" index="1">
        <power>true</power>
        <display>Ch2 Power</display>
        <treeDisplay>Channel 2</treeDisplay>
        <group>Scope</group>
        <limit>
          <label>Power</label>
          <symbol>U</symbol>
          <unit>${sourceUnit}</unit> <!-- will be squared due to 'power' -->
          <pmin>-1.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <featureIndex>1</featureIndex>
      </signalRule>
      <signalRule name="1PwrBWN" index="1">
        <power>true</power>
        <display>Ch2 Power Spectral Density</display>
        <treeDisplay>Channel 2</treeDisplay>
        <group>Scope</group>
        <limit>
          <label>Power Spectral Density</label>
          <symbol>U</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit> <!-- will be squared due to 'power' -->
          <pmin>-1.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <featureIndex>1</featureIndex>
      </signalRule>
    </signalGroup>
  </leafRule>

<!-- sigouts -->

  <branchRule match="/dev[0-9]+/sigouts">
    <display>Signal Outputs</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/sigouts/([0-9]+)">
    <display>Output ${p1+1}</display>
    <featureIndex>${p1+2}</featureIndex>
    <!-- Dummy signal rules to deliver properties when 'Signal Output N' is selected for scope.
         Be careful with full tree lists with signals!
         Properties could be set directly to branchRule, but moved to a dummy signals as a hack for MF:
         MF scope uses index 12 for sigout, while HF2 uses 2 & 3, therefore separate signals -->
    <signalGroup>
      <signalRule name="sigouthf2" index="0" devicetype="HF2">
        <display>Signal Output ${p1+1}</display>
        <limit>
          <label>Wave</label>
          <symbol>U</symbol>
          <unit>V</unit>
          <pmin>-1.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <scopeIndex>${p1+2}</scopeIndex>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="sigoutmfli" index="0" devicetype="MF">
        <display>Signal Output ${p1+1}</display>
        <limit>
          <label>Wave</label>
          <symbol>U</symbol>
          <unit>V</unit>
          <pmin>-1.0</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <scopeIndex>${p1+12}</scopeIndex>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
    </signalGroup>
  </branchRule>

<!-- AWG -->
  <branchRule match="/dev[0-9]+/awgs">
    <display>AWG</display>
    <signalGroup>
      <signalRule name="awgtriggeruhf1" index="0">
        <display>AWG Trigger 1</display>
        <scopeIndex>192</scopeIndex>
        <unitCalcSelector>BASE</unitCalcSelector>
        <featureIndex>192</featureIndex>
      </signalRule>
      <signalRule name="awgtriggeruhf2" index="1">
        <display>AWG Trigger 2</display>
        <scopeIndex>193</scopeIndex>
        <unitCalcSelector>BASE</unitCalcSelector>
        <featureIndex>193</featureIndex>
      </signalRule>
      <signalRule name="awgtriggeruhf3" index="2">
        <display>AWG Trigger 3</display>
        <scopeIndex>194</scopeIndex>
        <unitCalcSelector>BASE</unitCalcSelector>
        <featureIndex>194</featureIndex>
      </signalRule>
      <signalRule name="awgtriggeruhf4" index="3">
        <display>AWG Trigger 4</display>
        <scopeIndex>195</scopeIndex>
        <unitCalcSelector>BASE</unitCalcSelector>
        <featureIndex>195</featureIndex>
      </signalRule>
      <signalRule name="awgmarkeruhf1" index="4">
        <display>AWG Marker 1</display>
        <scopeIndex>176</scopeIndex>
        <unitCalcSelector>BASE</unitCalcSelector>
        <featureIndex>176</featureIndex>
      </signalRule>
      <signalRule name="awgmarkeruhf2" index="5">
        <display>AWG Marker 2</display>
        <scopeIndex>177</scopeIndex>
        <unitCalcSelector>BASE</unitCalcSelector>
        <featureIndex>177</featureIndex>
      </signalRule>
      <signalRule name="awgmarkeruhf3" index="6">
        <display>AWG Marker 3</display>
        <scopeIndex>178</scopeIndex>
        <unitCalcSelector>BASE</unitCalcSelector>
        <featureIndex>178</featureIndex>
      </signalRule>
      <signalRule name="awgmarkeruhf4" index="7">
        <display>AWG Marker 4</display>
        <scopeIndex>179</scopeIndex>
        <unitCalcSelector>BASE</unitCalcSelector>
        <featureIndex>179</featureIndex>
      </signalRule>
    </signalGroup>
  </branchRule>
<!-- Signal output -->

  <branchRule match="/dev[0-9]+/sigouts/([0-9]+)/amplitudes">
    <display>Amplitudes</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/sigouts/([0-9]+)/amplitudes/([0-9]+)">
    <dataType>undefined</dataType>
    <display>Output ${p1+1} Amplitude ${p2+1}</display>
    <treeDisplay>Amplitude ${p2+1}</treeDisplay>
    <group>Sigout Amplitude</group>
    <limit>
      <label>Amplitude</label>
      <symbol>U</symbol> <!-- TODO(2K): For sweeper X axis it was hard-coded to 'r'. Is it important? See r38377. -->
      <unit>V</unit>
      <pmin>0.0</pmin>
      <pmax>2.0</pmax>
      <mapping>LINEAR</mapping>
    </limit>
    <unitCalcSelector>RAW</unitCalcSelector>
    <signal>Amplitude ${p2+1}</signal>
  </leafRule>

  <leafRule match="/dev[0-9]+/sigouts/([0-9]+)/offset">
    <dataType>double</dataType>
    <display>Output ${p1+1} Offset</display>
    <treeDisplay>Offset</treeDisplay>
    <group>Sigout Offset</group>
    <limit>
      <label>Offset</label>
      <symbol>U</symbol> <!-- TODO(2K): For sweeper X axis it was hard-coded to 'off'. Is it important? See r38377. -->
      <unit>V</unit>
      <pmin>-2.0</pmin>
      <pmax>2.0</pmax>
      <mapping>LINEAR</mapping>
    </limit>
    <unitCalcSelector>RAW</unitCalcSelector>
    <signal>Offset</signal>
  </leafRule>

  <leafRule match="/dev[0-9]+/sigouts/([0-9]+)/autorange">
    <dataType>int</dataType>
    <display>Autorange</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/sigouts/([0-9]+)/enables">
    <display>Enables</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/sigouts/([0-9]+)/enables/([0-9]+)">
    <dataType>int</dataType>
    <display>Enable ${p2+1}</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/sigouts/([0-9]+)/imp50">
    <dataType>int</dataType>
    <display>50 Ohm</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/sigouts/([0-9]+)/on">
    <dataType>int</dataType>
    <display>On</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/sigouts/([0-9]+)/over">
    <dataType>int</dataType>
    <display>Overload</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/sigouts/([0-9]+)/range">
    <dataType>double</dataType>
    <display>Range</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/sigouts/([0-9]+)/add">
    <dataType>int</dataType>
    <display>Add</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/sigouts/([0-9]+)/waveforms">
    <display>Waveforms</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/sigouts/([0-9]+)/waveforms/([0-9]+)">
    <dataType>int</dataType>
    <display>${p2+1}</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/sigouts/([0-9]+)/diff">
    <dataType>int</dataType>
    <display>Diff</display>
  </leafRule>

<!-- stats -->

  <branchRule match="/dev[0-9]+/stats">
    <display>Statistics</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/stats/cmdstream">
    <display>Command Stream</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/stats/cmdstream/bandwidth">
    <dataType>double</dataType>
    <display>Command Bandwidth</display>
    <treeDisplay>Bandwidth</treeDisplay>
    <group>Bandwidth</group>
    <limit>
      <label>Bandwidth</label>
      <symbol>val</symbol>
      <unit>Mb/s</unit>
      <pmin>-2.0</pmin>
      <pmax>2.0</pmax>
      <mapping>LINEAR</mapping>
    </limit>
    <unitCalcSelector>RAW</unitCalcSelector>
    <signal>Bandwidth</signal>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/cmdstream/bytesreceived">
    <dataType>int</dataType>
    <display>Bytes Received</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/cmdstream/bytessent">
    <dataType>int</dataType>
    <display>Bytes Sent</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/cmdstream/packetslost">
    <dataType>int</dataType>
    <display>Packets Lost</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/cmdstream/packetsreceived">
    <dataType>int</dataType>
    <display>Packets Received</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/cmdstream/pending">
    <dataType>int</dataType>
    <display>Pending</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/cmdstream/processing">
    <dataType>int</dataType>
    <display>Processing</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/stats/datastream">
    <display>Data Stream</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/stats/cpuload">
    <dataType>undefined</dataType>
    <display>CPU Load</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/dataservercpuload">
    <dataType>undefined</dataType>
    <display>Data Server CPU Load</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/dataservermemload">
    <dataType>undefined</dataType>
    <display>Data Server Memory Load</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/memload">
    <dataType>undefined</dataType>
    <display>Memory Load</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/datastream/bandwidth">
    <dataType>double</dataType>
    <display>Data Bandwidth</display>
    <treeDisplay>Bandwidth</treeDisplay>
    <group>Bandwidth</group>
    <limit>
      <label>Bandwidth</label>
      <symbol>val</symbol>
      <unit>Mb/s</unit>
      <pmin>-2.0</pmin>
      <pmax>2.0</pmax>
      <mapping>LINEAR</mapping>
    </limit>
    <unitCalcSelector>RAW</unitCalcSelector>
    <signal>Bandwidth</signal>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/datastream/bytesreceived">
    <dataType>int</dataType>
    <display>Bytes Received</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/datastream/bytessent">
    <dataType>int</dataType>
    <display>Bytes Sent</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/datastream/packetslost">
    <dataType>int</dataType>
    <display>Packets Lost</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/datastream/packetsreceived">
    <dataType>int</dataType>
    <display>Packets Received</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/datastream/pending">
    <dataType>int</dataType>
    <display>Pending</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/datastream/processing">
    <dataType>int</dataType>
    <display>Processing</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/stats/physical">
    <display>Physical</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/stats/physical/currents">
    <display>Currents</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/stats/physical/currents/([0-9]+)">
    <dataType>double</dataType>
    <display>Current ${p1+1}</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/physical/fanspeed">
    <dataType>double</dataType>
    <display>Fan Speed</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/stats/physical/fpga">
    <display>FPGA</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/stats/physical/fpga/aux">
    <dataType>double</dataType>
    <display>Aux</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/physical/fpga/core">
    <dataType>double</dataType>
    <display>Core</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/physical/fpga/temp">
    <dataType>double</dataType>
    <display>Temperature</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/stats/physical/temperatures">
    <display>Temperatures</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/stats/physical/temperatures/([0-9]+)">
    <dataType>double</dataType>
    <display>Temp ${p1+1}</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/stats/physical/voltages">
    <display>Voltages</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/stats/physical/voltages/([0-9]+)">
    <dataType>double</dataType>
    <display>Voltage ${p1+1}</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/physical/1v2">
    <dataType>double</dataType>
    <display>FPGA Core</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/physical/1v8">
    <dataType>double</dataType>
    <display>FPGA Aux 1</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/physical/2v5">
    <dataType>double</dataType>
    <display>FPGA Aux 2</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/physical/3v3">
    <dataType>double</dataType>
    <display>FPGA Aux 3</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/physical/5v0">
    <dataType>double</dataType>
    <display>FPGA Aux 4</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/physical/temp">
    <dataType>double</dataType>
    <display>FPGA Temp</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/bytesreceived">
    <dataType>double</dataType>
    <display>Bytes Received</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/bytessent">
    <dataType>int</dataType>
    <display>Bytes Sent</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/meanmsgcnt">
    <dataType>double</dataType>
    <display>Average Message Count</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/stats/meanpollcnt">
    <dataType>double</dataType>
    <display>Average Poll Count</display>
  </leafRule>


<!-- auxins -->

  <branchRule match="/dev[0-9]+/auxins">
    <display>Auxiliary Inputs</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/auxins/([0-9]+)">
    <display>Aux In ${p1+1}</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/auxins/([0-9]+)/averaging">
    <dataType>int</dataType>
    <display>Averaging</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/auxins/([0-9]+)/values">
    <display>Values</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/auxins/([0-9]+)/values/([0-9]+)">
    <dataType>double</dataType>
    <display>${p2+1}</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/auxins/([0-9]+)/sample">
    <dataType>sample</dataType>
    <display>Aux In ${p1+1} Sample</display>
    <treeDisplay>Sample</treeDisplay>
    <signalGroup>
      <signalRule name="0" index="0">
        <display>Aux In ${p1+1} Ch 1</display>
        <treeDisplay>Channel 1</treeDisplay>
        <scopeIndex>8</scopeIndex>
        <unitCalcSelector>BASE</unitCalcSelector>
        <featureIndex>8</featureIndex>
      </signalRule>
      <signalRule name="1" index="1">
        <display>Aux In ${p1+1} Ch 2</display>
        <treeDisplay>Channel 2</treeDisplay>
        <scopeIndex>9</scopeIndex>
        <unitCalcSelector>BASE</unitCalcSelector>
        <featureIndex>9</featureIndex>
      </signalRule>
      <signalRule name="AuxIn0" index="6">
        <display>Aux In 1</display>
        <treeDisplay>Aux In 1</treeDisplay>
        <variable>auxin0</variable>
        <group>Aux In</group>
        <limit>
          <label>Aux In</label>
          <symbol>In1</symbol>
          <unit>V</unit>
          <pmin>-10.0</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="AuxIn1" index="7">
        <display>Aux In 2</display>
        <treeDisplay>Aux In 2</treeDisplay>
        <variable>auxin1</variable>
        <group>Aux In</group>
        <limit>
          <label>Aux In</label>
          <symbol>In2</symbol>
          <unit>V</unit>
          <pmin>-10.0</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
    </signalGroup>
  </leafRule>


  <leafRule match="/dev[0-9]+/clockbase">
    <dataType>double</dataType>
    <display>Clock Base</display>
  </leafRule>

<!-- dios -->

  <branchRule match="/dev[0-9]+/dios">
    <display>Digital IOs</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/dios/([0-9]+)">
    <display>DIO ${p1+1}</display>
    <scopeIndex>${p1+12}</scopeIndex> <!-- HF2 -->
    <unitCalcSelector>DIO</unitCalcSelector>
  </branchRule>

  <leafRule match="/dev[0-9]+/dios/([0-9]+)/decimation">
    <dataType>undefined</dataType>
    <display>Decimation</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/dios/([0-9]+)/drive">
    <dataType>int</dataType>
    <display>Drive</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/dios/([0-9]+)/extclk">
    <dataType>int</dataType>
    <display>External Clock</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/dios/([0-9]+)/input">
    <dataType>int</dataType>
    <display>Input</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/dios/([0-9]+)/output">
    <dataType>int</dataType>
    <display>Output</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/dios/([0-9]+)/syncselect0">
    <dataType>int</dataType>
    <display>Sync Select 0</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/dios/([0-9]+)/syncselect1">
    <dataType>int</dataType>
    <display>Sync Select 1</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/dios/([0-9]+)/mode">
    <dataType>int</dataType>
    <display>Mode</display>
  </leafRule>

<!-- extrefs -->

  <branchRule match="/dev[0-9]+/extrefs">
    <display>External References</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/extrefs/([0-9]+)">
    <display>Ext Ref ${p1+1}</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/extrefs/([0-9]+)/adcselect">
    <dataType>int</dataType>
    <display>Input Signal</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/extrefs/([0-9]+)/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>


<!-- features -->

  <branchRule match="/dev[0-9]+/features">
    <display>Features</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/features/code">
    <dataType>undefined</dataType>
    <display>Code</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/features/devtype">
    <dataType>undefined</dataType>
    <display>Device Type</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/features/options">
    <dataType>undefined</dataType>
    <display>Options</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/features/serial">
    <dataType>undefined</dataType>
    <display>Serial Number</display>
  </leafRule>

<!-- feedbacks -->

  <branchRule match="/dev[0-9]+/feedbacks">
    <display>Feedbacks</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/feedbacks/([0-9]+)">
    <display>Feedback ${p1+1}</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/feedbacks/([0-9]+)/demodselect">
    <dataType>undefined</dataType>
    <display>Channel Selection</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/feedbacks/([0-9]+)/offset">
    <dataType>undefined</dataType>
    <display>Offset</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/feedbacks/([0-9]+)/outputselect">
    <dataType>undefined</dataType>
    <display>Signal Selection</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/feedbacks/([0-9]+)/preoffset">
    <dataType>undefined</dataType>
    <display>Pre-Offset</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/feedbacks/([0-9]+)/scale">
    <dataType>undefined</dataType>
    <display>Scale Factor</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/feedbacks/([0-9]+)/value">
    <dataType>undefined</dataType>
    <display>Value</display>
  </leafRule>

<!-- inputpwas -->

  <branchRule match="/dev[0-9]+/inputpwas">
    <display>Input PWAs</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/inputpwas/([0-9]+)">
    <display>Input PWA ${p1+1}</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/inputpwas/([0-9]+)/acquisitiontime">
    <dataType>double</dataType>
    <display>Acquisition Time</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/inputpwas/([0-9]+)/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/inputpwas/([0-9]+)/harmonic">
    <dataType>int</dataType>
    <display>Harmonic</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/inputpwas/([0-9]+)/holdoff">
    <dataType>double</dataType>
    <display>Holdoff</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/inputpwas/([0-9]+)/inputinterlock">
    <dataType>int</dataType>
    <display>Input Interlock</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/inputpwas/([0-9]+)/inputselect">
    <dataType>int</dataType>
    <display>Input Selection</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/inputpwas/([0-9]+)/looptime">
    <dataType>double</dataType>
    <display>Loop Time</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/inputpwas/([0-9]+)/mode">
    <dataType>undefined</dataType>
    <display>Mode</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/inputpwas/([0-9]+)/oscselect">
    <dataType>int</dataType>
    <display>Oscillator Selection</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/inputpwas/([0-9]+)/progress">
    <dataType>double</dataType>
    <display>Progress</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/inputpwas/([0-9]+)/samplecount">
    <dataType>int</dataType>
    <display>Sample Count</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/inputpwas/([0-9]+)/shift">
    <dataType>double</dataType>
    <display>Shift</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/inputpwas/([0-9]+)/single">
    <dataType>int</dataType>
    <display>Single</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/inputpwas/([0-9]+)/status">
    <dataType>undefined</dataType>
    <display>Status</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/inputpwas/([0-9]+)/termination">
    <dataType>undefined</dataType>
    <display>Termination</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/inputpwas/([0-9]+)/wave">
    <dataType>double</dataType>
    <display>Wave</display>
    <unitCalcSelector>INPUTPWA</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
    <signalGroup>
      <signalRule name="X" index="0">
        <display>Waveform</display>
        <variable>x</variable>
        <group>PWA Waveform</group>
        <limit>
          <label>Waveform</label>
          <symbol>Waveform</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Y" index="1">
        <display>Y</display>
        <variable>y</variable>
        <group>PWA Waveform</group>
        <limit>
          <label>Waveform</label>
          <symbol>Y</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="R" index="2">
        <display>R</display>
        <variable>r</variable>
        <group>PWA Waveform</group>
        <limit>
          <label>Waveform</label>
          <symbol>R</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Theta" index="3">
        <display>Phase</display>
        <variable>phase</variable>
        <group>PWA Phase</group>
        <limit>
          <label>Phase</label>
          <symbol>&#920;</symbol>
          <unit>deg</unit> <!-- TODO(2K): is PWA Theta delivered in degrees? -->
          <pmin>-PI</pmin>
          <pmax>PI</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="Count" index="4">
        <display>Count</display>
        <variable>count</variable>
        <group>PWA Count per Bin</group>
        <limit>
          <label>Count per Bin</label>
          <symbol>&#35;</symbol>
          <unit>pts</unit>
          <pmin>0.0</pmin>
          <pmax>1.0e6</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
    </signalGroup>
  </leafRule>

<!-- outputpwas -->

  <branchRule match="/dev[0-9]+/outputpwas">
    <display>Output PWAs</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/outputpwas/([0-9]+)">
    <display>Output PWA ${p1+1}</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/outputpwas/([0-9]+)/acquisitiontime">
    <dataType>double</dataType>
    <display>Acquisition Time</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/outputpwas/([0-9]+)/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/outputpwas/([0-9]+)/harmonic">
    <dataType>int</dataType>
    <display>Harmonic</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/outputpwas/([0-9]+)/holdoff">
    <dataType>double</dataType>
    <display>Holdoff</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/outputpwas/([0-9]+)/inputinterlock">
    <dataType>undefined</dataType>
    <display>Input Interlock</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/outputpwas/([0-9]+)/inputselect">
    <dataType>int</dataType>
    <display>Input Selection</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/outputpwas/([0-9]+)/looptime">
    <dataType>double</dataType>
    <display>Loop Time</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/outputpwas/([0-9]+)/mode">
    <dataType>undefined</dataType>
    <display>Mode</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/outputpwas/([0-9]+)/oscselect">
    <dataType>int</dataType>
    <display>Oscillator Selection</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/outputpwas/([0-9]+)/progress">
    <dataType>double</dataType>
    <display>Progress</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/outputpwas/([0-9]+)/samplecount">
    <dataType>int</dataType>
    <display>Sample Count</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/outputpwas/([0-9]+)/shift">
    <dataType>double</dataType>
    <display>Shift</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/outputpwas/([0-9]+)/single">
    <dataType>int</dataType>
    <display>Single</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/outputpwas/([0-9]+)/status">
    <dataType>undefined</dataType>
    <display>Status</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/outputpwas/([0-9]+)/termination">
    <dataType>undefined</dataType>
    <display>Termination</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/outputpwas/([0-9]+)/wave">
    <dataType>double</dataType>
    <display>Wave</display>
    <unitCalcSelector>OUTPUTPWA</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
    <signalGroup>
      <signalRule name="X" index="0">
        <display>Waveform</display>
        <variable>x</variable>
        <group>OutPWA Waveform</group>
        <limit>
          <label>Waveform</label>
          <symbol>Waveform</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Y" index="1">
        <display>Y</display>
        <variable>y</variable>
        <group>OutPWA Waveform</group>
        <limit>
          <label>Waveform</label>
          <symbol>Y</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="R" index="2">
        <display>R</display>
        <variable>r</variable>
        <group>OutPWA Waveform</group>
        <limit>
          <label>Waveform</label>
          <symbol>R</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Theta" index="3">
        <display>Phase</display>
        <variable>phase</variable>
        <group>PWA Phase</group>
        <limit>
          <label>Phase</label>
          <symbol>&#920;</symbol>
          <unit>deg</unit> <!-- TODO(2K): is PWA Theta delivered in degrees? -->
          <pmin>-PI</pmin>
          <pmax>PI</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="Count" index="4">
        <display>Count</display>
        <variable>count</variable>
        <group>PWA Count per Bin</group>
        <limit>
          <label>Count per Bin</label>
          <symbol>&#35;</symbol>
          <unit>pts</unit>
          <pmin>0.0</pmin>
          <pmax>1.0e6</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
    </signalGroup>
  </leafRule>

<!-- plls -->

  <branchRule match="/dev[0-9]+/plls">
    <display>Plls</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/plls/([0-9]+)">
    <display>Pll ${p1+1}</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/autobw">
    <dataType>int</dataType>
    <display>Auto Bandwidth</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/autocoeff">
    <dataType>int</dataType>
    <display>Auto Coefficient</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/center">
    <dataType>double</dataType>
    <display>Center</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/d">
    <dataType>double</dataType>
    <display>D</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/demodselect">
    <dataType>int</dataType>
    <display>Demod Selection</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/dlimittimeconstant">
    <dataType>double</dataType>
    <display>D Time Constant Limit</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/i">
    <dataType>double</dataType>
    <display>I</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/limitlower">
    <dataType>double</dataType>
    <display>Lower Limit</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/limitupper">
    <dataType>double</dataType>
    <display>Upper Limit</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/lowbw">
    <dataType>int</dataType>
    <display>Low Bandwidth</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/order">
    <dataType>int</dataType>
    <display>Filter Order</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/oscselect">
    <dataType>int</dataType>
    <display>Oscillator Selection</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/p">
    <dataType>double</dataType>
    <display>P</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/phaseunwrap">
    <dataType>int</dataType>
    <display>Phase Unwrap</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/rate">
    <dataType>double</dataType>
    <display>Sampling Rate</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/setpoint">
    <dataType>double</dataType>
    <display>Setpoint</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/timeconstant">
    <dataType>double</dataType>
    <display>PLL ${p1+1} Time Constant</display>
    <treeDisplay>Time Constant</treeDisplay>
    <group>PLL</group>
    <limit>
      <label>Time Constant</label>
      <symbol>T</symbol>
      <unit>s</unit>
      <pmin>-2.0</pmin>
      <pmax>2.0</pmax>
      <mapping>LINEAR</mapping>
    </limit>
    <unitCalcSelector>RAW</unitCalcSelector>
    <signal>Time Constant</signal>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/adcselect">
    <dataType>int</dataType>
    <display>Input</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/adcthreshold">
    <dataType>int</dataType>
    <display>Input Threshold</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/autocenter">
    <dataType>int</dataType>
    <display>Auto Center Freq</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/autopid">
    <dataType>int</dataType>
    <display>Auto PID</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/autotimeconstant">
    <dataType>int</dataType>
    <display>Auto Time Constant</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/auxavg">
    <dataType>int</dataType>
    <display>Aux Avg</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/error">
    <dataType>double</dataType>
    <display>Error</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/freqcenter">
    <dataType>double</dataType>
    <display>Center Frequency</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/freqdelta">
    <dataType>double</dataType>
    <display>Frequency Deviation</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/freqrange">
    <dataType>int</dataType>
    <display>Frequency Range</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/plls/([0-9]+)/harmonic">
    <dataType>int</dataType>
    <display>Harmonic</display>
  </leafRule>

<!-- sigins -->

  <branchRule match="/dev[0-9]+/sigins">
    <display>Signal Inputs</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/sigins/([0-9]+)">
    <display>Signal Input ${p1+1}</display>
    <scopeIndex>${p1}</scopeIndex>
    <unitCalcSelector>BASE</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
  </branchRule>

  <leafRule match="/dev[0-9]+/sigins/([0-9]+)/ac">
    <dataType>int</dataType>
    <display>AC Coupling</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/sigins/([0-9]+)/autorange">
    <dataType>int</dataType>
    <display>Autorange</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/sigins/([0-9]+)/bw">
    <dataType>int</dataType>
    <display>Bandwidth</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/sigins/([0-9]+)/imp50">
    <dataType>int</dataType>
    <display>50 Ohm</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/sigins/([0-9]+)/max">
    <dataType>double</dataType>
    <display>Max</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/sigins/([0-9]+)/min">
    <dataType>double</dataType>
    <display>Min</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/sigins/([0-9]+)/on">
    <dataType>int</dataType>
    <display>On</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/sigins/([0-9]+)/range">
    <dataType>double</dataType>
    <display>Range</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/sigins/([0-9]+)/diff">
    <dataType>int</dataType>
    <display>Diff</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/sigins/([0-9]+)/scaling">
    <dataType>double</dataType>
    <display>Scaling</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/sigins/([0-9]+)/float">
    <dataType>int</dataType>
    <display>Float</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/sigins/([0-9]+)/rangestep">
    <display>Range Step</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/sigins/([0-9]+)/rangestep/trigger">
    <dataType>int</dataType>
    <display>Trigger</display>
  </leafRule>

<!-- currins -->

  <branchRule match="/dev[0-9]+/currins">
    <display>Current Inputs</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/currins/([0-9]+)">
    <display>Current Input ${p1+1}</display>
    <scopeIndex>${p1+1}</scopeIndex>
    <unitCalcSelector>BASE</unitCalcSelector>
    <featureIndex>${p1+1}</featureIndex>
  </branchRule>

  <leafRule match="/dev[0-9]+/currins/([0-9]+)/autorange">
    <dataType>int</dataType>
    <display>Autorange</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/currins/([0-9]+)/imp50">
    <dataType>int</dataType>
    <display>50 Ohm</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/currins/([0-9]+)/max">
    <dataType>double</dataType>
    <display>Max</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/currins/([0-9]+)/min">
    <dataType>double</dataType>
    <display>Min</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/currins/([0-9]+)/on">
    <dataType>int</dataType>
    <display>On</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/currins/([0-9]+)/range">
    <dataType>double</dataType>
    <display>Range</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/currins/([0-9]+)/float">
    <dataType>int</dataType>
    <display>Floating Ground</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/currins/([0-9]+)/over">
    <dataType>undefined</dataType>
    <display>Overflow</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/currins/([0-9]+)/rangestep">
    <display>Range Step</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/currins/([0-9]+)/rangestep/trigger">
    <dataType>int</dataType>
    <display>Trigger</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/currins/([0-9]+)/scaling">
    <dataType>double</dataType>
    <display>Scaling</display>
  </leafRule>


<!-- status -->

  <branchRule match="/dev[0-9]+/status">
    <display>Status</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/status/adc0max">
    <dataType>int</dataType>
    <display>ADC 0 Max</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/status/adc0min">
    <dataType>int</dataType>
    <display>ADC 0 Min</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/status/adc1max">
    <dataType>int</dataType>
    <display>ADC 1 Max</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/status/adc1min">
    <dataType>int</dataType>
    <display>ADC 1 Min</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/status/fifolevel">
    <dataType>undefined</dataType>
    <display>FIFO Level</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/status/flags">
    <display>Flags</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/status/flags/binary">
    <dataType>int</dataType>
    <display>Binary</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/status/flags/packetlosstcp">
    <dataType>undefined</dataType>
    <display>Packet Loss TCP</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/status/flags/packetlossudp">
    <dataType>undefined</dataType>
    <display>Packet Loss UDP</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/status/flags/packetlossusb">
    <dataType>undefined</dataType>
    <display>Packet Loss USB</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/status/flags/time">
    <dataType>undefined</dataType>
    <display>Time</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/status/flags/adcclip">
    <display>ADC Clipping</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/status/flags/adcclip/([0-9]+)">
    <dataType>int</dataType>
    <display>${p1}</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/status/flags/dcmlock">
    <dataType>int</dataType>
    <display>DCM Locked</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/status/flags/demodsampleloss">
    <dataType>int</dataType>
    <display>Demod Sample Loss</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/status/flags/fx2rx">
    <dataType>int</dataType>
    <display>FX2RX</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/status/flags/mixerclip">
    <display>DCM Locked</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/status/flags/mixerclip/([0-9]+)">
    <dataType>int</dataType>
    <display>${p1}</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/status/flags/pkgloss">
    <dataType>int</dataType>
    <display>Package Loss</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/status/flags/plllock">
    <dataType>int</dataType>
    <display>Internal PLL Locked</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/status/flags/scopeskipped">
    <dataType>int</dataType>
    <display>Scope Data Skipped</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/status/echoread">
    <dataType>int</dataType>
    <display>Echo Read</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/status/echowrite">
    <dataType>int</dataType>
    <display>Echo Write</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/status/time">
    <dataType>int</dataType>
    <display>Timestamp</display>
  </leafRule>

<!-- system -->

  <branchRule match="/dev[0-9]+/system">
    <display>System</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/system/activeinterface">
    <dataType>undefined</dataType>
    <display>Active Interface</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/system/boardrevisions">
    <display>Board Revisions</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/system/boardrevisions/([0-9]+)">
    <dataType>undefined</dataType>
    <display>Rev ${p1+1}</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/system/calib">
    <display>Calibration</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/system/calib/auto">
    <dataType>int</dataType>
    <display>Auto</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/calib/calibrate">
    <dataType>int</dataType>
    <display>Calibrate</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/calib/next">
    <dataType>int</dataType>
    <display>Next</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/calib/required">
    <dataType>int</dataType>
    <display>Required</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/calib/tempthreshold">
    <dataType>double</dataType>
    <display>Temperature Threshold</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/calib/timeinterval">
    <dataType>int</dataType>
    <display>Time Interval</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/system/compdelay">
    <display>Compensation Delay</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/system/compdelay/calibrate">
    <dataType>int</dataType>
    <display>Calibrate</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/system/compdelay/delays">
    <display>Delays</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/system/compdelay/delays/([0-9]+)">
    <dataType>int</dataType>
    <display>Delay ${p1+1}</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/extclk">
    <dataType>int</dataType>
    <display>External Clock</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/fpgarevision">
    <dataType>int</dataType>
    <display>FPGA Revision</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/fwlog">
    <dataType>undefined</dataType>
    <display>FW Log</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/fwlogenable">
    <dataType>undefined</dataType>
    <display>FW Log Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/fwrevision">
    <dataType>undefined</dataType>
    <display>FW Revision</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/fx2revision">
    <dataType>undefined</dataType>
    <display>FX2 USB Revision</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/jumbo">
    <dataType>int</dataType>
    <display>Jumbo Frames</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/hwrevision">
    <dataType>int</dataType>
    <display>Hardware</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/syncenable">
    <dataType>int</dataType>
    <display>Sync Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/syncreset">
    <dataType>int</dataType>
    <display>Sync Reset</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/synctime">
    <dataType>double</dataType>
    <display>Sync Time</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/system/nics">
    <display>NICs</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/system/nics/([0-9]+)">
    <display>NIC ${p1+1}</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/system/nics/([0-9]+)/defaultgateway">
    <dataType>undefined</dataType>
    <display>Default Gateway</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/nics/([0-9]+)/defaultip4">
    <dataType>undefined</dataType>
    <display>Default IPv4</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/nics/([0-9]+)/defaultmask">
    <dataType>undefined</dataType>
    <display>Default Mask</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/nics/([0-9]+)/gateway">
    <dataType>undefined</dataType>
    <display>Gateway</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/nics/([0-9]+)/ip4">
    <dataType>undefined</dataType>
    <display>IPv4</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/nics/([0-9]+)/jumbo">
    <dataType>int</dataType>
    <display>Jumbo Frames</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/nics/([0-9]+)/mac">
    <dataType>undefined</dataType>
    <display>MAC Address</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/nics/([0-9]+)/mask">
    <dataType>undefined</dataType>
    <display>Mask</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/nics/([0-9]+)/saveip">
    <dataType>int</dataType>
    <display>Save IP</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/nics/([0-9]+)/static">
    <dataType>int</dataType>
    <display>Static IP</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/owner">
    <dataType>undefined</dataType>
    <display>Owner</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/porttcp">
    <dataType>undefined</dataType>
    <display>TCP Port</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/portudp">
    <dataType>undefined</dataType>
    <display>UDP Port</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/portudp">
    <dataType>int</dataType>
    <display>Stall</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/powerconfigdate">
    <dataType>undefined</dataType>
    <display>Power Config Date</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/preampenable">
    <dataType>int</dataType>
    <display>Preamplifier Enable</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/system/preset">
    <display>Preset</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/system/preset/busy">
    <dataType>int</dataType>
    <display>Busy</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/preset/default">
    <dataType>int</dataType>
    <display>Default</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/preset/erase">
    <dataType>int</dataType>
    <display>Erase</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/preset/error">
    <dataType>int</dataType>
    <display>Error</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/preset/index">
    <dataType>int</dataType>
    <display>Index</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/preset/load">
    <dataType>int</dataType>
    <display>Load</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/system/preset/records">
    <display>Records</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/system/preset/records/([0-9]+)">
    <display>Record ${p1+1}</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/system/preset/records/([0-9]+)/features">
    <dataType>undefined</dataType>
    <display>Features</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/preset/records/([0-9]+)/label">
    <dataType>undefined</dataType>
    <display>Label</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/preset/records/([0-9]+)/timestamp">
    <dataType>undefined</dataType>
    <display>Time Stamp</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/preset/records/([0-9]+)/valid">
    <dataType>int</dataType>
    <display>Valid</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/preset/save">
    <dataType>int</dataType>
    <display>Save</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/saveports">
    <dataType>undefined</dataType>
    <display>Save Ports</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/xenpakenable">
    <dataType>int</dataType>
    <display>10Gb XENPAK Enable</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/system/properties">
    <display>Properties</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/system/properties/freqresolution">
    <dataType>double</dataType>
    <display>Frequency Resolution</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/properties/freqscaling">
    <dataType>double</dataType>
    <display>Frequency Scaling</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/properties/maxfreq">
    <dataType>double</dataType>
    <display>Max Frequency</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/properties/minfreq">
    <dataType>double</dataType>
    <display>Min Frequency</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/properties/maxtimeconstant">
    <dataType>double</dataType>
    <display>Max Time Constant</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/properties/mintimeconstant">
    <dataType>double</dataType>
    <display>Min Time Constant</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/properties/negativefreq">
    <dataType>int</dataType>
    <display>Negative Frequencies</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/system/properties/timebase">
    <dataType>double</dataType>
    <display>Time Base</display>
  </leafRule>
<!-- cpus -->
  <branchRule match="/dev[0-9]+/cpus">
    <display>CPUs</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/cpus/([0-9]+)">
    <display>${p1+1}</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/cpus/([0-9]+)/output">
    <dataType>undefined</dataType>
    <display>Output</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/cpus/([0-9]+)/program">
    <dataType>undefined</dataType>
    <display>Program</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/cpus/([0-9]+)/userregs">
    <display>User Registers</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/cpus/([0-9]+)/userregs/([0-9]+)">
    <dataType>int</dataType>
    <display>${p2+1}</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/cpus/([0-9]+)/workload">
    <dataType>double</dataType>
    <display>Workload</display>
  </leafRule>

<!-- zctrls -->
  <branchRule match="/dev[0-9]+/zctrls">
    <display>ZCTRLs</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/zctrls/([0-9]+)">
    <display>${p1+1}</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/zctrls/([0-9]+)/camp">
    <display>HF2CA</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/zctrls/([0-9]+)/camp/available">
    <dataType>int</dataType>
    <display>Available</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/zctrls/([0-9]+)/camp/dc">
    <dataType>int</dataType>
    <display>DC</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/zctrls/([0-9]+)/camp/gain">
    <dataType>int</dataType>
    <display>Gain</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/zctrls/([0-9]+)/camp/r">
    <dataType>int</dataType>
    <display>R</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/zctrls/([0-9]+)/camp/singleended">
    <dataType>int</dataType>
    <display>Single</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/zctrls/([0-9]+)/tamp">
    <display>HF2TA</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/zctrls/([0-9]+)/tamp/available">
    <dataType>int</dataType>
    <display>Available</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/zctrls/([0-9]+)/tamp/biasout">
    <dataType>double</dataType>
    <display>Bias Out</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/zctrls/([0-9]+)/tamp/extbias">
    <dataType>int</dataType>
    <display>Input Shield</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/zctrls/([0-9]+)/tamp/([0-9]+)">
    <display>${p2+1}</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/zctrls/([0-9]+)/tamp/([0-9]+)/currentgain">
    <dataType>int</dataType>
    <display>Current Gain</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/zctrls/([0-9]+)/tamp/([0-9]+)/dc">
    <dataType>int</dataType>
    <display>DC</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/zctrls/([0-9]+)/tamp/([0-9]+)/offset">
    <dataType>double</dataType>
    <display>Offset</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/zctrls/([0-9]+)/tamp/([0-9]+)/voltagegain">
    <dataType>int</dataType>
    <display>Voltage Gain</display>
  </leafRule>


<!-- triggers -->
  <branchRule match="/dev[0-9]+/triggers">
    <display>Triggers</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/triggers/in">
    <display>Trigger Input</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/triggers/in/([0-9]+)">
    <display>Trig Input ${p1+1}</display>
    <scopeIndex>${p1+2}</scopeIndex>
    <unitCalcSelector>BASE</unitCalcSelector>
    <featureIndex>${p1+2}</featureIndex>
  </branchRule>

  <leafRule match="/dev[0-9]+/triggers/in/([0-9]+)/imp50">
    <dataType>int</dataType>
    <display>50 Ohm</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/triggers/in/([0-9]+)/level">
    <dataType>double</dataType>
    <display>Level</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/triggers/out">
    <display>Trigger Output</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/triggers/out/([0-9]+)">
    <display>Trig Output ${p1+1}</display>
    <scopeIndex>${p1+14}</scopeIndex>
  </branchRule>

  <leafRule match="/dev[0-9]+/triggers/out/([0-9]+)/drive">
    <dataType>int</dataType>
    <display>Drive</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/triggers/out/([0-9]+)/pulsewidth">
    <dataType>double</dataType>
    <display>Pulse width</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/triggers/out/([0-9]+)/source">
    <dataType>int</dataType>
    <display>Source</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/triggers/out/([0-9]+)/delay">
    <dataType>double</dataType>
    <display>Delay</display>
  </leafRule>

<!-- awgs -->
  <branchRule match="/dev[0-9]+/awgs">
    <display>AWGs</display>
    <noSkip>true</noSkip>
  </branchRule>

  <branchRule match="/dev[0-9]+/awgs/([0-9]+)">
    <display>AWG ${p1+1}</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/awgs/([0-9]+)/sweep">
    <display>Sweep</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/awgs/([0-9]+)/sweep/awgtrigs">
    <display>Index Sweep Triggers</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/awgs/([0-9]+)/sweep/awgtrigs/([0-9]+)">
    <display>AWG Trigger ${p2+1}</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/awgs/([0-9]+)/auxtriggers">
    <display>Aux Triggers</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/awgs/([0-9]+)/auxtriggers/([0-9]+)">
    <display>${p2+1}</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/auxtriggers/([0-9]+)/channel">
    <dataType>int</dataType>
    <display>Channel</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/awgs/([0-9]+)/elf">
    <display>Elf</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/elf/checksum">
    <dataType>int</dataType>
    <display>Channel</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/elf/data">
    <dataType>vector</dataType>
    <display>Data</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/elf/name">
    <dataType>vector</dataType>
    <display>Name</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/elf/memoryusage">
    <dataType>double</dataType>
    <display>Memory Usage</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/awgs/([0-9]+)/outputs">
    <display>Outputs</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/awgs/([0-9]+)/outputs/([0-9]+)">
    <display>Output ${p2+1}</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/outputs/([0-9]+)/amplitude">
    <dataType>double</dataType>
    <display>Output ${p2+1} Amplitude</display>
    <treeDisplay>Amplitude</treeDisplay>
  </leafRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/outputs/([0-9]+)/mode">
    <dataType>int</dataType>
    <display>Mode</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/rate">
    <dataType>double</dataType>
    <display>Rate</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/awgs/([0-9]+)/sequencer">
    <display>Sequencer</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/sequencer/assembly">
    <dataType>vector</dataType>
    <display>Assembly</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/sequencer/continue">
    <dataType>int</dataType>
    <display>Continue</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/sequencer/next">
    <dataType>int</dataType>
    <display>Next</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/sequencer/pc">
    <dataType>int</dataType>
    <display>Program Counter</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/sequencer/memoryusage">
    <dataType>double</dataType>
    <display>Memory Usage</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/sequencer/program">
    <dataType>vector</dataType>
    <display>Program</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/sequencer/status">
    <dataType>int</dataType>
    <display>Status</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/single">
    <dataType>int</dataType>
    <display>Single</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/awgs/([0-9]+)/triggers">
    <display>Triggers</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/awgs/([0-9]+)/triggers/([0-9]+)">
    <display>Trigger ${p2+1}</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/triggers/([0-9]+)/channel">
    <dataType>int</dataType>
    <display>Channel</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/triggers/([0-9]+)/falling">
    <dataType>int</dataType>
    <display>Falling</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/triggers/([0-9]+)/force">
    <dataType>int</dataType>
    <display>Force</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/awgs/([0-9]+)/triggers/([0-9]+)/gate">
    <display>Gate</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/triggers/([0-9]+)/gate/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/triggers/([0-9]+)/gate/inputselect">
    <dataType>int</dataType>
    <display>Input Select</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/awgs/([0-9]+)/triggers/([0-9]+)/hysteresis">
    <display>Hysteresis</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/triggers/([0-9]+)/hysteresis/absolute">
    <dataType>double</dataType>
    <display>Absolute</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/triggers/([0-9]+)/hysteresis/relative">
    <dataType>double</dataType>
    <display>Relative</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/triggers/([0-9]+)/hysteresis/mode">
    <dataType>int</dataType>
    <display>Mode</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/triggers/([0-9]+)/level">
    <dataType>double</dataType>
    <display>Trig ${p2+1} Level</display>
    <treeDisplay>Level</treeDisplay>
  </leafRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/triggers/([0-9]+)/rising">
    <dataType>int</dataType>
    <display>Rising</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/awgs/([0-9]+)/userregs">
    <display>User Registers</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/userregs/([0-9]+)">
    <dataType>int</dataType>
    <display>Reg ${p2 + 1}</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/awgs/([0-9]+)/waveform">
    <display>Waveform</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/waveform/data">
    <dataType>vector</dataType>
    <display>Data</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/waveform/descriptors">
    <dataType>vector</dataType>
    <display>Descriptors</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/waveform/index">
    <dataType>int</dataType>
    <display>Index</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/awgs/([0-9]+)/waveform/memoryusage">
    <dataType>double</dataType>
    <display>Memory Usage</display>
  </leafRule>

<!-- zi -->

  <branchRule match="/zi">
    <display>Zurich Instruments</display>
  </branchRule>

  <branchRule match="/zi/about">
    <display>About</display>
  </branchRule>

  <leafRule match="/zi/about/copyright">
    <dataType>undefined</dataType>
    <display>Copyright</display>
  </leafRule>

  <leafRule match="/zi/about/dataserver">
    <dataType>undefined</dataType>
    <display>Data Server</display>
  </leafRule>

  <leafRule match="/zi/about/fwrevision">
    <dataType>undefined</dataType>
    <display>FW Revision</display>
  </leafRule>

  <leafRule match="/zi/about/revision">
    <dataType>int</dataType>
    <display>Revision</display>
  </leafRule>

  <leafRule match="/zi/about/version">
    <dataType>undefined</dataType>
    <display>Version</display>
  </leafRule>

  <leafRule match="/zi/clockbase">
    <dataType>undefined</dataType>
    <display>Clock Base</display>
  </leafRule>

  <branchRule match="/zi/config">
    <display>Config</display>
  </branchRule>

  <leafRule match="/zi/config/open">
    <dataType>int</dataType>
    <display>Open</display>
  </leafRule>

  <leafRule match="/zi/config/port">
    <dataType>undefined</dataType>
    <display>Port</display>
  </leafRule>

  <branchRule match="/zi/devices">
    <display>Devices</display>
  </branchRule>

  <leafRule match="/zi/devices/connected">
    <dataType>undefined</dataType>
    <display>Connected</display>
  </leafRule>

  <leafRule match="/zi/devices/discover">
    <dataType>undefined</dataType>
    <display>Discover</display>
  </leafRule>

  <leafRule match="/zi/devices/visible">
    <dataType>undefined</dataType>
    <display>Visible</display>
  </leafRule>

  <leafRule match="/zi/trees">
    <dataType>undefined</dataType>
    <display>Trees</display>
  </leafRule>

<!-- Virtual nodes -->
<!-- TODO(2K): hack, develop configurable virtual nodes system -->

  <leafRule match="/hf2scopeoff">
    <dataType>undefined</dataType>
    <display>Scope Off</display>
    <scopeIndex>-1</scopeIndex>
    <unitCalcSelector>EMPTY</unitCalcSelector>
  </leafRule>

  <leafRule match="/hf2scopecont">
    <dataType>undefined</dataType>
    <display>Scope Continuous</display>
    <scopeIndex>-2</scopeIndex>
    <unitCalcSelector>EMPTY</unitCalcSelector>
  </leafRule>

  <leafRule match="/bode">
    <dataType>undefined</dataType>
    <display>Bode</display>
    <signalGroup>
      <signalRule name="R" index="2">
        <display>Magnitude</display>
        <limit>
          <label>Response</label>
          <symbol>R</symbol>
          <unit></unit>
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="Theta" index="3">
        <display>Phase</display>
        <limit>
          <label>Phase</label>
          <symbol>&#920;</symbol>
          <unit>rad</unit>
          <pmin>-PI</pmin>
          <pmax>PI</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
    </signalGroup>
  </leafRule>

  <leafRule match="/impulse">
    <dataType>undefined</dataType>
    <display>Impulse</display>
    <signalGroup>
      <signalRule name="R" index="2">
        <display>R</display>
        <limit>
          <label>Response</label>
          <symbol>R</symbol>
          <unit></unit>
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
    </signalGroup>
  </leafRule>

  <leafRule match="/step">
    <dataType>undefined</dataType>
    <display>Step Response</display>
    <signalGroup>
      <signalRule name="X" index="0">
        <display>X</display>
        <limit>
          <label>Response</label>
          <symbol>X</symbol>
          <unit></unit>
          <pmin>-2.0</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
    </signalGroup>
  </leafRule>

  <!-- Impedance -->
  <branchRule match="/dev[0-9]+/imps">
    <display>Impedances</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/imps/([0-9]+)">
    <display>Impedance ${p1+1}</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/imps/([0-9]+)/calib">
    <display>Calibration</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/imps/([0-9]+)/calib/internal">
    <display>Internal</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/calib/internal/active">
    <dataType>int</dataType>
    <display>Active</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/calib/internal/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/calib/internal/store">
    <dataType>int</dataType>
    <display>Store</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/calib/internal/data">
    <dataType>vector</dataType>
    <display>Data</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/imps/([0-9]+)/calib/user">
    <display>User</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/calib/user/active">
    <dataType>int</dataType>
    <display>Active</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/calib/user/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/calib/user/store">
    <dataType>int</dataType>
    <display>Store</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/calib/user/data">
    <dataType>vector</dataType>
    <display>Data</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/calib/internal/valid">
    <dataType>int</dataType>
    <display>Valid</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/calib/user/valid">
    <dataType>int</dataType>
    <display>Valid</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/calib/internal/info">
    <dataType>undefined</dataType>
    <display>Info</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/calib/user/info">
    <dataType>undefined</dataType>
    <display>Info</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/calib/cablelength">
    <dataType>int</dataType>
    <display>Cable Length</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/application">
    <dataType>int</dataType>
    <display>Application</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/imps/([0-9]+)/auto">
    <display>Auto</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/auto/bw">
    <dataType>int</dataType>
    <display>Bandwidth</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/auto/inputrange">
    <dataType>int</dataType>
    <display>Range</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/auto/output">
    <dataType>int</dataType>
    <display>Output</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/auto/suppress">
    <dataType>int</dataType>
    <display>Suppress</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/imps/([0-9]+)/current">
    <display>Current</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/current/range">
    <dataType>double</dataType>
    <display>Range</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/current/demodselect">
    <dataType>int</dataType>
    <display>Current Demod Select</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/current/inputselect">
    <dataType>int</dataType>
    <display>Current Input Select</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/current/invert">
    <dataType>int</dataType>
    <display>Current Invert</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/filter">
    <dataType>int</dataType>
    <display>Filter</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/mode">
    <dataType>int</dataType>
    <display>Mode</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/model">
    <dataType>int</dataType>
    <display>Representation</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/imps/([0-9]+)/output">
    <display>Output</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/output/on">
    <dataType>int</dataType>
    <display>On</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/output/range">
    <dataType>double</dataType>
    <display>Range</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/output/demod">
    <dataType>int</dataType>
    <display>Demod</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/output/select">
    <dataType>int</dataType>
    <display>Output Select</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/output/amplitude">
    <dataType>double</dataType>
    <display>Amplitude</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/imps/([0-9]+)/confidence">
    <display>Confidence</display>
  </branchRule>

  <branchRule match="/dev[0-9]+/imps/([0-9]+)/confidence/suppression">
    <display>Suppression</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/confidence/suppression/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/confidence/suppression/ratio">
    <dataType>double</dataType>
    <display>Ratio</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/imps/([0-9]+)/confidence/compensation">
    <display>Compensation</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/confidence/compensation/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/confidence/compensation/ratio">
    <dataType>double</dataType>
    <display>Ratio</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/imps/([0-9]+)/confidence/opendetect">
    <display>Open Detect</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/confidence/opendetect/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/confidence/opendetect/ratio">
    <dataType>double</dataType>
    <display>Ratio</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/imps/([0-9]+)/confidence/underflow">
    <display>Underflow</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/confidence/underflow/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/confidence/underflow/ratio">
    <dataType>double</dataType>
    <display>Ratio</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/imps/([0-9]+)/voltage">
    <display>Voltage</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/voltage/range">
    <dataType>double</dataType>
    <display>Range</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/voltage/demodselect">
    <dataType>int</dataType>
    <display>Voltage Demod Select</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/voltage/inputselect">
    <dataType>int</dataType>
    <display>Voltage Input Select</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/voltage/invert">
    <dataType>int</dataType>
    <display>Voltage Invert</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/imps/([0-9]+)/demod">
    <display>Demodulator</display>
  </branchRule> 
  
  <leafRule match="/dev[0-9]+/imps/([0-9]+)/demod/harmonic">
    <dataType>int</dataType>
    <display>Harmonic</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/demod/oscselect">
    <dataType>int</dataType>
    <display>Oscillator</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/demod/timeconstant">
    <dataType>double</dataType>
    <display>Time Constant</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/demod/order">
    <dataType>int</dataType>
    <display>Order</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/demod/sinc">
    <dataType>int</dataType>
    <display>Sinc</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/demod/rate">
    <dataType>double</dataType>
    <display>Rate</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/ac">
    <dataType>int</dataType>
    <display>AC Coupling</display>
  </leafRule>

  <branchRule match="/dev[0-9]+/imps/([0-9]+)/bias">
    <display>Bias</display>
  </branchRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/bias/enable">
    <dataType>int</dataType>
    <display>Enable</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/bias/value">
    <dataType>double</dataType>
    <display>Value</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/freq">
    <dataType>double</dataType>
    <display>Frequency</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/impedancerange">
    <dataType>int</dataType>
    <display>Impedance Range</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/interpolation">
    <dataType>int</dataType>
    <display>Interpolation</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/maxbandwidth">
    <dataType>double</dataType>
    <display>Max Bandwidth</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/omegasuppression">
    <dataType>double</dataType>
    <display>Omega Suppression</display>
  </leafRule>

  <leafRule match="/dev[0-9]+/imps/([0-9]+)/sample">
    <dataType>sample</dataType>
    <display>Impedance ${p1+1} Sample</display>
    <treeDisplay>Sample</treeDisplay>
    <unitCalcSelector>RAW</unitCalcSelector>
    <featureIndex>${p1}</featureIndex>
    <signalGroup>
      <signalRule name="RealZ" index="0">
        <display>Impedance ${p1+1} Real(Z)</display>
        <treeDisplay>Real(Z)</treeDisplay>
        <variable>realz</variable>
        <group>Impedance</group>
        <limit>
          <label>Impedance</label>
          <symbol>Real(Z)</symbol>
          <unit>Ohm</unit>
          <!-- TODO (RC): Define min and max impedance. These are just guesses. -->
          <pmin>-1.0e7</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="ImagZ" index="1">
        <display>Impedance ${p1+1} Imag(Z)</display>
        <treeDisplay>Imag(Z)</treeDisplay>
        <variable>imagz</variable>
        <group>Impedance</group>
        <limit>
          <label>Impedance</label>
          <symbol>Imag(Z)</symbol>
          <unit>Ohm</unit>
          <!-- TODO (RC): Define min and max impedance. These are just guesses. -->
          <pmin>-1.0e7</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="AbsZ" index="2">
        <display>Impedance ${p1+1} Abs(Z)</display>
        <treeDisplay>Abs(Z)</treeDisplay>
        <variable>absz</variable>
        <group>Impedance</group>
        <limit>
          <label>Impedance</label>
          <symbol>Abs(Z)</symbol>
          <unit>Ohm</unit>
          <!-- TODO (RC): Define min and max impedance. These are just guesses. -->
          <pmin>0.1</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="PhaseZ" index="3">
        <display>Impedance ${p1+1} Phase(Z)</display>
        <treeDisplay>Phase(Z)</treeDisplay>
        <variable>phasez</variable>
        <group>Impedance</group>
        <limit>
          <label>Phase(Z)</label>
          <symbol>&#920;</symbol>
          <unit>rad</unit>
          <pmin>-PI</pmin>
          <pmax>PI</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Frequency" index="4">
        <display>Impedance ${p1+1} Frequency</display>
        <treeDisplay>Frequency</treeDisplay>
        <variable>frequency</variable>
        <group>Impedance</group>
        <limit>
          <label>Osc Frequency</label>
          <symbol>f</symbol>
          <unit>Hz</unit>
          <pmin>0</pmin>
          <pmax>1.8e9</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Param0" index="6">
        <display>Impedance ${p1+1} Rep Param 1</display>
        <treeDisplay>Rep Parameter 1</treeDisplay>
        <variable>param0</variable>
        <group>Impedance</group>
        <limit>
          <label>Impedance</label>
          <symbol>M1</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>0.1</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>IMP_M1</unitCalcSelector>
      </signalRule>
      <signalRule name="Param1" index="7">
        <display>Impedance ${p1+1} Rep Param 2</display>
        <treeDisplay>Rep Parameter 2</treeDisplay>
        <variable>param1</variable>
        <group>Impedance</group>
        <limit>
          <label>Impedance</label>
          <symbol>M2</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>0.1</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>IMP_M2</unitCalcSelector>
      </signalRule>
      <signalRule name="Drive" index="10">  <!-- index 8/9 are reserved for flags/trigger -->
        <display>Impedance ${p1+1} Drive Amplitude</display>
        <treeDisplay>Drive Amplitude</treeDisplay>
        <variable>drive</variable>
        <group>Impedance</group>
        <limit>
          <label>Impedance</label>
          <symbol>Drive</symbol>
          <unit>V</unit>
          <pmin>-1.0e7</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Bias" index="11">
        <display>Impedance ${p1+1} Bias Voltage</display>
        <treeDisplay>Bias Voltage</treeDisplay>
        <variable>bias</variable>
        <group>Impedance</group>
        <limit>
          <label>Impedance</label>
          <symbol>Bias</symbol>
          <unit>V</unit>
          <pmin>-1.0e7</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>

      <!-- sweeper derived signals - RMS -->
      <signalRule name="RealZRms" index="0" module="sweeper"> <!-- index important for flags matching -->
        <display>Std Deviation Real(Z)</display>
        <variable>realzstddev</variable>
        <group>Impedance</group>
        <limit>
          <label>Std Deviation</label>
          <symbol>Real(Z)rms</symbol>
          <unit>Ohm</unit>
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="ImagZRms" index="1" module="sweeper"> <!-- index important for flags matching -->
        <display>Std Deviation Imag(Z)</display>
        <variable>imagzstddev</variable>
        <group>Impedance</group>
        <limit>
          <label>Std Deviation</label>
          <symbol>Imag(Z)rms</symbol>
          <unit>Ohm</unit>
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="AbsZRms" index="2" module="sweeper"> <!-- index important for flags matching -->
        <display>Std Deviation Abs(Z)</display>
        <variable>abszstddev</variable>
        <group>Impedance</group>
        <limit>
          <label>Std Deviation</label>
          <symbol>Abs(Z)rms</symbol>
          <unit>Ohm</unit>
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="PhaseZRms" index="3" module="sweeper"> <!-- index important for flags matching -->
        <display>Phase Noise</display>
        <variable>phasezstddev</variable>
        <group>Impedance</group>
        <limit>
          <label>Phase Noise</label>
          <symbol>&#920;rms</symbol>
          <unit>rad</unit>
          <pmin>1e-12</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
<!--
      <signalRule name="FreqRms" index="4" module="sweeper"> <!- - index important for flags matching - ->
        <display>Osc Frequency Noise</display>
        <variable>frequencystddev</variable>
        <group>Impedance</group>
        <limit>
          <label>Osc Frequency Noise</label>
          <symbol>frms</symbol>
          <unit>Hz</unit>
          <pmin>1e-9</pmin>
          <pmax>1e3</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
-->
      <signalRule name="Param0Rms" index="6" module="sweeper"> <!-- index important for flags matching -->
        <display>StdDev Rep Parameter 1</display>
        <variable>param0stddev</variable>
        <group>Impedance</group>
        <limit>
          <label>StdDev Rep Parameter 1</label>
          <symbol>M1rms</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>1e-12</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>IMP_M1</unitCalcSelector>
      </signalRule>
      <signalRule name="Param1Rms" index="7" module="sweeper"> <!-- index important for flags matching -->
        <display>StdDev Rep Parameter 2</display>
        <variable>param1stddev</variable>
        <group>Impedance</group>
        <limit>
          <label>StdDev Rep Parameter 2</label>
          <symbol>M2rms</symbol>
          <unit>${sourceUnit}</unit>
          <pmin>1e-12</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>IMP_M2</unitCalcSelector>
      </signalRule>

      <!-- sweeper derived signals - Pwr -->
      <signalRule name="RealZPwr" index="0" module="sweeper"> <!-- index important for flags matching -->
        <power>true</power>
        <display>Power Impedance Real(Z)</display>
        <variable>realzpwr</variable>
        <group>Impedance</group>
        <limit>
          <label>Power Impedance</label>
          <symbol>Real(Z)&#178;avg</symbol>
          <unit>Ohm</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="ImagZPwr" index="1" module="sweeper"> <!-- index important for flags matching -->
        <power>true</power>
        <display>Power Impedance Imag(Z)</display>
        <variable>imagzpwr</variable>
        <group>Impedance</group>
        <limit>
          <label>Power Impedance</label>
          <symbol>Imag(Z)&#178;avg</symbol>
          <unit>Ohm</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="AbsZPwr" index="2" module="sweeper"> <!-- index important for flags matching -->
        <power>true</power>
        <display>Power Impedance abs(Z)</display>
        <variable>abszpwr</variable>
        <group>Impedance</group>
        <limit>
          <label>Power Impedance</label>
          <symbol>Abs(Z)&#178;avg</symbol>
          <unit>Ohm</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="PhaseZPwr" index="3" module="sweeper"> <!-- index important for flags matching -->
        <power>true</power>
        <display>Power Phase(Z)</display>
        <variable>phasezpwr</variable>
        <group>Impedance</group>
        <limit>
          <label>Power Phase</label>
          <symbol>&#920;(Z)&#178;avg</symbol>
          <unit>rad/rad</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-12</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="Param0Pwr" index="6" module="sweeper"> <!-- index important for flags matching -->
        <power>true</power>
        <display>Power Rep Parameter 1</display>
        <variable>param0pwr</variable>
        <group>Impedance</group>
        <limit>
          <label>Power Rep Parameter 1</label>
          <symbol>M1&#178;avg</symbol>
          <unit>${sourceUnit}</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-12</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>IMP_M1</unitCalcSelector>
      </signalRule>
      <signalRule name="Param1Pwr" index="7" module="sweeper"> <!-- index important for flags matching -->
        <power>true</power>
        <display>Power Rep Parameter 2</display>
        <variable>param1pwr</variable>
        <group>Impedance</group>
        <limit>
          <label>Norm Rep Parameter 2</label>
          <symbol>M2&#178;avg</symbol>
          <unit>${sourceUnit}</unit> <!-- will be squared due to 'power' -->
          <pmin>1e-12</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>IMP_M2</unitCalcSelector>
      </signalRule>

      <!-- sweeper derived signals - BWN -->
      <signalRule name="RealZBWN" index="0" module="sweeper"> <!-- index important for flags matching -->
        <bw>true</bw>
        <display>Real(Z) 1Hz BW</display>
        <variable>realz</variable>
        <group>Impedance</group>
        <limit>
          <label>1Hz BW</label>
          <symbol>Real(Z)avg/sqrt(Hz)</symbol>
          <unit>Ohm/Hz^0.5</unit>
          <!-- TODO (RC): Define min and max impedance. These are just guesses. -->
          <pmin>-1.0e7</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="ImagZBWN" index="1" module="sweeper"> <!-- index important for flags matching -->
        <bw>true</bw>
        <display>Imag(Z) 1Hz BW</display>
        <variable>imagz</variable>
        <group>Impedance</group>
        <limit>
          <label>1Hz BW</label>
          <symbol>Imag(Z)avg/sqrt(Hz)</symbol>
          <unit>Ohm/Hz^0.5</unit>
          <!-- TODO (RC): Define min and max impedance. These are just guesses. -->
          <pmin>-1.0e7</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="AbsZBWN" index="2" module="sweeper"> <!-- index important for flags matching -->
        <bw>true</bw>
        <display>Abs(Z) 1Hz BW</display>
        <variable>absz</variable>
        <group>Impedance</group>
        <limit>
          <label>1Hz BW</label>
          <symbol>Abs(Z)avg/sqrt(Hz)</symbol>
          <unit>Ohm/Hz^0.5</unit>
          <!-- TODO (RC): Define min and max impedance. These are just guesses. -->
          <pmin>0.1</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="PhaseZBWN" index="3" module="sweeper"> <!-- index important for flags matching -->
        <bw>true</bw>
        <display>Phase(Z) 1Hz BW</display>
        <variable>phasez</variable>
        <group>Impedance</group>
        <limit>
          <label>1Hz BW</label>
          <symbol>&#920;(Z)avg/sqrt(Hz)</symbol>
          <unit>rad/Hz^0.5</unit>
          <pmin>-PI</pmin>
          <pmax>PI</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Param0BWN" index="6" module="sweeper"> <!-- index important for flags matching -->
        <bw>true</bw>
        <display>Rep Parameter 1 1Hz BW</display>
        <variable>param0</variable>
        <group>Impedance</group>
        <limit>
          <label>1Hz BW</label>
          <symbol>M1avg/sqrt(Hz)</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>0.1</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>IMP_M1</unitCalcSelector>
      </signalRule>
      <signalRule name="Param1BWN" index="7" module="sweeper"> <!-- index important for flags matching -->
        <bw>true</bw>
        <display>Rep Parameter 2 1Hz BW</display>
        <variable>param1</variable>
        <group>Impedance</group>
        <limit>
          <label>1Hz BW</label>
          <symbol>M2avg/sqrt(Hz)</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>0.1</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>IMP_M2</unitCalcSelector>
      </signalRule>

      <!-- sweeper derived signals - RmsBWN -->
      <signalRule name="RealZRmsBWN" index="0" module="sweeper"> <!-- index important for flags matching -->
        <bw>true</bw>
        <display>Real(Z) Noise 1Hz BW</display>
        <variable>realzstddev</variable>
        <group>Impedance</group>
        <limit>
          <label>Noise 1Hz BW</label>
          <symbol>Real(Z)rms/sqrt(Hz)</symbol>
          <unit>Ohm/Hz^0.5</unit>
          <!-- TODO (RC): Define min and max impedance. These are just guesses. -->
          <pmin>-1.0e7</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="ImagZRmsBWN" index="1" module="sweeper"> <!-- index important for flags matching -->
        <bw>true</bw>
        <display>Imag(Z) Noise 1Hz BW</display>
        <variable>imagzstddev</variable>
        <group>Impedance</group>
        <limit>
          <label>Noise 1Hz BW</label>
          <symbol>Imag(Z)rms/sqrt(Hz)</symbol>
          <unit>Ohm/Hz^0.5</unit>
          <!-- TODO (RC): Define min and max impedance. These are just guesses. -->
          <pmin>-1.0e7</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="AbsZRmsBWN" index="2" module="sweeper"> <!-- index important for flags matching -->
        <bw>true</bw>
        <display>Abs(Z) Noise 1Hz BW</display>
        <variable>abszstddev</variable>
        <group>Impedance</group>
        <limit>
          <label>Noise 1Hz BW</label>
          <symbol>Abs(Z)rms/sqrt(Hz)</symbol>
          <unit>Ohm/Hz^0.5</unit>
          <!-- TODO (RC): Define min and max impedance. These are just guesses. -->
          <pmin>0.1</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="PhaseZRmsBWN" index="3" module="sweeper"> <!-- index important for flags matching -->
        <bw>true</bw>
        <display>Phase(Z) Noise 1Hz BW</display>
        <variable>phasezstddev</variable>
        <group>Impedance</group>
        <limit>
          <label>Noise 1Hz BW</label>
          <symbol>&#920;(Z)rms/sqrt(Hz)</symbol>
          <unit>rad/Hz^0.5</unit>
          <pmin>-PI</pmin>
          <pmax>PI</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Param0RmsBWN" index="6" module="sweeper"> <!-- index important for flags matching -->
        <bw>true</bw>
        <display>Rep Parameter 1 Noise 1Hz BW</display>
        <variable>param0stddev</variable>
        <group>Impedance</group>
        <limit>
          <label>Noise 1Hz BW</label>
          <symbol>M1rms/sqrt(Hz)</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>0.1</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>IMP_M1</unitCalcSelector>
      </signalRule>
      <signalRule name="Param1RmsBWN" index="7" module="sweeper"> <!-- index important for flags matching -->
        <bw>true</bw>
        <display>Rep Parameter 2 Noise 1Hz BW</display>
        <variable>param1stddev</variable>
        <group>Impedance</group>
        <limit>
          <label>Noise 1Hz BW</label>
          <symbol>M2rms/sqrt(Hz)</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit>
          <pmin>0.1</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>IMP_M2</unitCalcSelector>
      </signalRule>

      <!-- sweeper derived signals - PwrBWN -->
      <signalRule name="RealZPwrBWN" index="0" module="sweeper"> <!-- index important for flags matching -->
        <bw>true</bw>
        <power>true</power>
        <display>Power Real(Z) 1Hz BW</display>
        <variable>realzpwr</variable>
        <group>Impedance</group>
        <limit>
          <label>Power 1Hz BW</label>
          <symbol>Real(Z)&#178;avg/Hz</symbol>
          <unit>Ohm/Hz^0.5</unit> <!-- unit will be squared by DynamicUnit due to 'power' -->
          <!-- TODO (RC): Define min and max impedance. These are just guesses. -->
          <pmin>-1.0e7</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="ImagZPwrBWN" index="1" module="sweeper"> <!-- index important for flags matching -->
        <bw>true</bw>
        <power>true</power>
        <display>Power Imag(Z) 1Hz BW</display>
        <variable>imagzpwr</variable>
        <group>Impedance</group>
        <limit>
          <label>Power 1Hz BW</label>
          <symbol>Imag(Z)&#178;avg/Hz</symbol>
          <unit>Ohm/Hz^0.5</unit> <!-- unit will be squared by DynamicUnit due to 'power' -->
          <!-- TODO (RC): Define min and max impedance. These are just guesses. -->
          <pmin>-1.0e7</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="AbsZPwrBWN" index="2" module="sweeper"> <!-- index important for flags matching -->
        <bw>true</bw>
        <power>true</power>
        <display>Power Abs(Z) 1Hz BW</display>
        <variable>abszpwr</variable>
        <group>Impedance</group>
        <limit>
          <label>Power 1Hz BW</label>
          <symbol>Abs(Z)&#178;avg/Hz</symbol>
          <unit>Ohm/Hz^0.5</unit> <!-- unit will be squared by DynamicUnit due to 'power' -->
          <!-- TODO (RC): Define min and max impedance. These are just guesses. -->
          <pmin>0.1</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="PhaseZPwrBWN" index="3" module="sweeper"> <!-- index important for flags matching -->
        <bw>true</bw>
        <power>true</power>
        <display>Power Phase(Z) 1Hz BW</display>
        <variable>phasezpwr</variable>
        <group>Impedance</group>
        <limit>
          <label>Power 1Hz BW</label>
          <symbol>&#920;(Z)&#178;avg/Hz</symbol>
          <unit>rad/Hz^0.5</unit> <!-- unit will be squared by DynamicUnit due to 'power' -->
          <pmin>-PI</pmin>
          <pmax>PI</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Param0PwrBWN" index="6" module="sweeper"> <!-- index important for flags matching -->
        <bw>true</bw>
        <power>true</power>
        <display>Power Rep Parameter 1 1Hz BW</display>
        <variable>param0pwr</variable>
        <group>Impedance</group>
        <limit>
          <label>Power 1Hz BW</label>
          <symbol>M1&#178;avg/Hz</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit> <!-- unit will be squared by DynamicUnit due to 'power' -->
          <pmin>0.1</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>IMP_M1</unitCalcSelector>
      </signalRule>
      <signalRule name="Param1PwrBWN" index="7" module="sweeper"> <!-- index important for flags matching -->
        <bw>true</bw>
        <power>true</power>
        <display>Power Rep Parameter 2 1Hz BW</display>
        <variable>param1pwr</variable>
        <group>Impedance</group>
        <limit>
          <label>Power 1Hz BW</label>
          <symbol>M2&#178;avg/Hz</symbol>
          <unit>${sourceUnit}/Hz^0.5</unit> <!-- unit will be squared by DynamicUnit due to 'power' -->
          <pmin>0.1</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>IMP_M2</unitCalcSelector>
      </signalRule>

      <!-- sweeper derived signals - Cal -->
      <signalRule name="RealZCal" index="0" module="sweeper"> <!-- index important for flags matching -->
        <sweeperReferenceType>COMPLEX_X</sweeperReferenceType>
        <display>Norm Impedance Real(Z)</display>
        <variable>realz</variable>
        <group>Impedance</group>
        <limit>
          <label>Norm Impedance</label>
          <symbol>Real(Z)avg/Real(Z)ref</symbol>
          <unit>Ohm/Ohm</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="ImagZCal" index="1" module="sweeper"> <!-- index important for flags matching -->
        <sweeperReferenceType>COMPLEX_Y</sweeperReferenceType>
        <display>Norm Impedance Imag(Z)</display>
        <variable>imagz</variable>
        <group>Impedance</group>
        <limit>
          <label>Norm Impedance</label>
          <symbol>Imag(Z)avg/Imag(Z)ref</symbol>
          <unit>Ohm/Ohm</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="AbsZCal" index="2" module="sweeper"> <!-- index important for flags matching -->
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Impedance Abs(Z)</display>
        <variable>absz</variable>
        <group>Impedance</group>
        <limit>
          <label>Norm Impedance</label>
          <symbol>Abs(Z)avg/Abs(Z)ref</symbol>
          <unit>Ohm/Ohm</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>2.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="PhaseZCal" index="3" module="sweeper"> <!-- index important for flags matching -->
        <sweeperReferenceType>SUB</sweeperReferenceType>
        <display>Norm Phase(Z)</display>
        <variable>phasez</variable>
        <group>Impedance</group>
        <limit>
          <label>Norm Phase</label>
          <symbol>&#920;(Z)avg-&#920;(Z)ref</symbol>
          <unit>rad</unit> <!-- TODO(2K): See note for units at the top -->
          <pmin>1e-12</pmin>
          <pmax>1.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="Param0Cal" index="6" module="sweeper"> <!-- index important for flags matching -->
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Rep Parameter 1</display>
        <variable>param0</variable>
        <group>Impedance</group>
        <limit>
          <label>Norm Rep Parameter 1</label>
          <symbol>M1avg/M1ref</symbol>
          <unit></unit> <!-- TODO(2K) -->
          <pmin>1e-12</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>
      <signalRule name="Param1Cal" index="7" module="sweeper"> <!-- index important for flags matching -->
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Rep Parameter 2</display>
        <variable>param1</variable>
        <group>Impedance</group>
        <limit>
          <label>Norm Rep Parameter 2</label>
          <symbol>M2avg/M2ref</symbol>
          <unit></unit> <!-- TODO(2K) -->
          <pmin>1e-12</pmin>
          <pmax>10.0</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>RAW</unitCalcSelector>
      </signalRule>

      <!-- sweeper derived signals - RmsCal -->
      <signalRule name="RealZRmsCal" index="0" module="sweeper"> <!-- index important for flags matching -->
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Dev Real(Z)</display>
        <variable>realzstddev</variable>
        <group>Impedance</group>
        <limit>
          <label>Norm Std Dev</label>
          <symbol>Real(Z)rms/Real(Z)rmsref</symbol>
          <unit>Ohm/Ohm</unit>
          <!-- TODO (RC): Define min and max impedance. These are just guesses. -->
          <pmin>-1.0e7</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="ImagZRmsCal" index="1" module="sweeper"> <!-- index important for flags matching -->
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Dev Imag(Z)</display>
        <variable>imagzstddev</variable>
        <group>Impedance</group>
        <limit>
          <label>Norm Std Dev</label>
          <symbol>Imag(Z)rms/Imag(Z)rmsref</symbol>
          <unit>Ohm/Ohm</unit>
          <!-- TODO (RC): Define min and max impedance. These are just guesses. -->
          <pmin>-1.0e7</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="AbsZRmsCal" index="2" module="sweeper"> <!-- index important for flags matching -->
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Dev Abs(Z)</display>
        <variable>abszstddev</variable>
        <group>Impedance</group>
        <limit>
          <label>Norm Std Dev</label>
          <symbol>Abs(Z)rms/Abs(Z)rmsref</symbol>
          <unit>Ohm/Ohm</unit>
          <!-- TODO (RC): Define min and max impedance. These are just guesses. -->
          <pmin>0.1</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="PhaseZRmsCal" index="3" module="sweeper"> <!-- index important for flags matching -->
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Dev Phase(Z)</display>
        <variable>phasezstddev</variable>
        <group>Impedance</group>
        <limit>
          <label>Norm Std Dev</label>
          <symbol>&#920;(Z)rms/&#920;(Z)rmsref</symbol>
          <unit>rad/rad</unit>
          <pmin>-PI</pmin>
          <pmax>PI</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Param0RmsCal" index="6" module="sweeper"> <!-- index important for flags matching -->
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Dev Rep Parameter 1</display>
        <variable>param0stddev</variable>
        <group>Impedance</group>
        <limit>
          <label>Norm Std Dev</label>
          <symbol>M1rms/M1rmsref</symbol>
          <unit>${sourceUnit}/${sourceUnit}</unit>
          <pmin>0.1</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>IMP_M1</unitCalcSelector>
      </signalRule>
      <signalRule name="Param1RmsCal" index="7" module="sweeper"> <!-- index important for flags matching -->
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Std Dev Rep Parameter 2</display>
        <variable>param1stddev</variable>
        <group>Impedance</group>
        <limit>
          <label>Norm Std Dev</label>
          <symbol>M2rms/M2rmsref</symbol>
          <unit>${sourceUnit}/${sourceUnit}</unit>
          <pmin>0.1</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>IMP_M2</unitCalcSelector>
      </signalRule>

      <!-- sweeper derived signals - PwrCal -->
      <signalRule name="RealZPwrCal" index="0" module="sweeper"> <!-- index important for flags matching -->
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Power Real(Z)</display>
        <variable>realzpwr</variable>
        <group>Impedance</group>
        <limit>
          <label>Norm Power</label>
          <symbol>Real(Z)&#178;avg/Real(Z)&#178;ref</symbol>
          <unit>Ohm/Ohm</unit> <!-- unit will be squared by DynamicUnit due to 'power' -->
          <!-- TODO (RC): Define min and max impedance. These are just guesses. -->
          <pmin>-1.0e7</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="ImagZPwrCal" index="1" module="sweeper"> <!-- index important for flags matching -->
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Power Imag(Z)</display>
        <variable>imagzpwr</variable>
        <group>Impedance</group>
        <limit>
          <label>Norm Power</label>
          <symbol>Imag(Z)&#178;avg/Imag(Z)&#178;ref</symbol>
          <unit>Ohm/Ohm</unit> <!-- unit will be squared by DynamicUnit due to 'power' -->
          <!-- TODO (RC): Define min and max impedance. These are just guesses. -->
          <pmin>-1.0e7</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="AbsZPwrCal" index="2" module="sweeper"> <!-- index important for flags matching -->
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Power Abs(Z)</display>
        <variable>abszpwr</variable>
        <group>Impedance</group>
        <limit>
          <label>Norm Power</label>
          <symbol>Abs(Z)&#178;avg/Abs(Z)&#178;ref</symbol>
          <unit>Ohm/Ohm</unit> <!-- unit will be squared by DynamicUnit due to 'power' -->
          <!-- TODO (RC): Define min and max impedance. These are just guesses. -->
          <pmin>0.1</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="PhaseZPwrCal" index="3" module="sweeper"> <!-- index important for flags matching -->
        <sweeperReferenceType>SUB</sweeperReferenceType>
        <display>Norm Phase(Z)</display>
        <variable>phasez</variable>
        <group>Impedance</group>
        <limit>
          <label>Norm</label>
          <symbol>&#920;(Z)avg-&#920;(Z)ref</symbol>
          <unit>rad</unit>
          <pmin>-PI</pmin>
          <pmax>PI</pmax>
          <mapping>LINEAR</mapping>
        </limit>
      </signalRule>
      <signalRule name="Param0PwrCal" index="6" module="sweeper"> <!-- index important for flags matching -->
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Power Rep Parameter 1</display>
        <variable>param0pwr</variable>
        <group>Impedance</group>
        <limit>
          <label>Norm Power</label>
          <symbol>M1&#178;avg/M1&#178;ref</symbol>
          <unit>${sourceUnit}/${sourceUnit}</unit> <!-- unit will be squared by DynamicUnit due to 'power' -->
          <pmin>0.1</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>IMP_M1</unitCalcSelector>
      </signalRule>
      <signalRule name="Param1PwrCal" index="7" module="sweeper"> <!-- index important for flags matching -->
        <power>true</power>
        <sweeperReferenceType>REAL</sweeperReferenceType>
        <display>Norm Power Rep Parameter 2</display>
        <variable>param1pwr</variable>
        <group>Impedance</group>
        <limit>
          <label>Norm Power</label>
          <symbol>M2&#178;avg/M2&#178;ref</symbol>
          <unit>${sourceUnit}/${sourceUnit}</unit> <!-- unit will be squared by DynamicUnit due to 'power' -->
          <pmin>0.1</pmin>
          <pmax>1.0e7</pmax>
          <mapping>LINEAR</mapping>
        </limit>
        <unitCalcSelector>IMP_M2</unitCalcSelector>
      </signalRule>

      <!-- sweeper derived signals - BWNCal -->
      <!-- TODO(2K) -->

      <!-- sweeper derived signals - RmsBWNCal -->
      <!-- TODO(2K) -->

      <!-- sweeper derived signals - PwrBWNCal -->
      <!-- TODO(2K) -->

    </signalGroup>
  </leafRule>

      <!-- Any unknown signal - TODO(2K): this is a workaround, should be handled internally -->
  <leafRule match=".*\.(.*)">
    <dataType>undefined</dataType>
    <display>${p1}</display>
  </leafRule>

</signalProps>
